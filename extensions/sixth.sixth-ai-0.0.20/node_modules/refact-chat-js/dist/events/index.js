var Rn = Object.defineProperty;
var wn = (e, t, r) => t in e ? Rn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var at = (e, t, r) => wn(e, typeof t != "symbol" ? t + "" : t, r);
function On(e, t) {
  for (var r = 0; r < t.length; r++) {
    const n = t[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in e)) {
          const s = Object.getOwnPropertyDescriptor(n, i);
          s && Object.defineProperty(e, i, s.get ? s : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
function bt(e) {
  return `Minified Redux error #${e}; visit https://redux.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
var ut = () => Math.random().toString(36).substring(7).split("").join("."), Tn = {
  INIT: `@@redux/INIT${/* @__PURE__ */ ut()}`,
  REPLACE: `@@redux/REPLACE${/* @__PURE__ */ ut()}`,
  PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${ut()}`
}, Jt = Tn;
function te(e) {
  if (typeof e != "object" || e === null)
    return !1;
  let t = e;
  for (; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t || Object.getPrototypeOf(e) === null;
}
function En(e) {
  Object.keys(e).forEach((t) => {
    const r = e[t];
    if (typeof r(void 0, {
      type: Jt.INIT
    }) > "u")
      throw new Error(bt(12));
    if (typeof r(void 0, {
      type: Jt.PROBE_UNKNOWN_ACTION()
    }) > "u")
      throw new Error(bt(13));
  });
}
function An(e) {
  const t = Object.keys(e), r = {};
  for (let s = 0; s < t.length; s++) {
    const u = t[s];
    typeof e[u] == "function" && (r[u] = e[u]);
  }
  const n = Object.keys(r);
  let i;
  try {
    En(r);
  } catch (s) {
    i = s;
  }
  return function(u = {}, c) {
    if (i)
      throw i;
    let o = !1;
    const y = {};
    for (let l = 0; l < n.length; l++) {
      const h = n[l], a = r[h], d = u[h], g = a(d, c);
      if (typeof g > "u")
        throw c && c.type, new Error(bt(14));
      y[h] = g, o = o || g !== d;
    }
    return o = o || n.length !== Object.keys(u).length, o ? y : u;
  };
}
function Dr(e) {
  return te(e) && "type" in e && typeof e.type == "string";
}
var It = Symbol.for("immer-nothing"), ve = Symbol.for("immer-draftable"), B = Symbol.for("immer-state");
function z(e, ...t) {
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var se = Object.getPrototypeOf;
function Z(e) {
  return !!e && !!e[B];
}
function Y(e) {
  var t;
  return e ? $r(e) || Array.isArray(e) || !!e[ve] || !!((t = e.constructor) != null && t[ve]) || Pe(e) || Me(e) : !1;
}
var Pn = Object.prototype.constructor.toString();
function $r(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = se(e);
  if (t === null)
    return !0;
  const r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return r === Object ? !0 : typeof r == "function" && Function.toString.call(r) === Pn;
}
function Mn(e) {
  return Z(e) || z(15, e), e[B].base_;
}
function Re(e, t) {
  ae(e) === 0 ? Reflect.ownKeys(e).forEach((r) => {
    t(r, e[r], e);
  }) : e.forEach((r, n) => t(n, r, e));
}
function ae(e) {
  const t = e[B];
  return t ? t.type_ : Array.isArray(e) ? 1 : Pe(e) ? 2 : Me(e) ? 3 : 0;
}
function we(e, t) {
  return ae(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function ct(e, t) {
  return ae(e) === 2 ? e.get(t) : e[t];
}
function qr(e, t, r) {
  const n = ae(e);
  n === 2 ? e.set(t, r) : n === 3 ? e.add(r) : e[t] = r;
}
function kn(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Pe(e) {
  return e instanceof Map;
}
function Me(e) {
  return e instanceof Set;
}
function ne(e) {
  return e.copy_ || e.base_;
}
function St(e, t) {
  if (Pe(e))
    return new Map(e);
  if (Me(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const r = $r(e);
  if (t === !0 || t === "class_only" && !r) {
    const n = Object.getOwnPropertyDescriptors(e);
    delete n[B];
    let i = Reflect.ownKeys(n);
    for (let s = 0; s < i.length; s++) {
      const u = i[s], c = n[u];
      c.writable === !1 && (c.writable = !0, c.configurable = !0), (c.get || c.set) && (n[u] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: c.enumerable,
        value: e[u]
      });
    }
    return Object.create(se(e), n);
  } else {
    const n = se(e);
    if (n !== null && r)
      return { ...e };
    const i = Object.create(n);
    return Object.assign(i, e);
  }
}
function Dt(e, t = !1) {
  return nt(e) || Z(e) || !Y(e) || (ae(e) > 1 && (e.set = e.add = e.clear = e.delete = Fn), Object.freeze(e), t && Object.entries(e).forEach(([r, n]) => Dt(n, !0))), e;
}
function Fn() {
  z(2);
}
function nt(e) {
  return Object.isFrozen(e);
}
var Ct = {};
function ue(e) {
  const t = Ct[e];
  return t || z(0, e), t;
}
function In(e, t) {
  Ct[e] || (Ct[e] = t);
}
var Oe;
function xr() {
  return Oe;
}
function Dn(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Yt(e, t) {
  t && (ue("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Rt(e) {
  wt(e), e.drafts_.forEach($n), e.drafts_ = null;
}
function wt(e) {
  e === Oe && (Oe = e.parent_);
}
function Xt(e) {
  return Oe = Dn(Oe, e);
}
function $n(e) {
  const t = e[B];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Zt(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const r = t.drafts_[0];
  return e !== void 0 && e !== r ? (r[B].modified_ && (Rt(t), z(4)), Y(e) && (e = Xe(t, e), t.parent_ || Ze(t, e)), t.patches_ && ue("Patches").generateReplacementPatches_(
    r[B].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Xe(t, r, []), Rt(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== It ? e : void 0;
}
function Xe(e, t, r) {
  if (nt(t))
    return t;
  const n = t[B];
  if (!n)
    return Re(
      t,
      (i, s) => jt(e, n, t, i, s, r)
    ), t;
  if (n.scope_ !== e)
    return t;
  if (!n.modified_)
    return Ze(e, n.base_, !0), n.base_;
  if (!n.finalized_) {
    n.finalized_ = !0, n.scope_.unfinalizedDrafts_--;
    const i = n.copy_;
    let s = i, u = !1;
    n.type_ === 3 && (s = new Set(i), i.clear(), u = !0), Re(
      s,
      (c, o) => jt(e, n, i, c, o, r, u)
    ), Ze(e, i, !1), r && e.patches_ && ue("Patches").generatePatches_(
      n,
      r,
      e.patches_,
      e.inversePatches_
    );
  }
  return n.copy_;
}
function jt(e, t, r, n, i, s, u) {
  if (Z(i)) {
    const c = s && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !we(t.assigned_, n) ? s.concat(n) : void 0, o = Xe(e, i, c);
    if (qr(r, n, o), Z(o))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else u && r.add(i);
  if (Y(i) && !nt(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Xe(e, i), (!t || !t.scope_.parent_) && typeof n != "symbol" && Object.prototype.propertyIsEnumerable.call(r, n) && Ze(e, i);
  }
}
function Ze(e, t, r = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Dt(t, r);
}
function qn(e, t) {
  const r = Array.isArray(e), n = {
    type_: r ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xr(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = n, s = $t;
  r && (i = [n], s = Te);
  const { revoke: u, proxy: c } = Proxy.revocable(i, s);
  return n.draft_ = c, n.revoke_ = u, c;
}
var $t = {
  get(e, t) {
    if (t === B)
      return e;
    const r = ne(e);
    if (!we(r, t))
      return xn(e, r, t);
    const n = r[t];
    return e.finalized_ || !Y(n) ? n : n === ft(e.base_, t) ? (lt(e), e.copy_[t] = Tt(n, e)) : n;
  },
  has(e, t) {
    return t in ne(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(ne(e));
  },
  set(e, t, r) {
    const n = Nr(ne(e), t);
    if (n != null && n.set)
      return n.set.call(e.draft_, r), !0;
    if (!e.modified_) {
      const i = ft(ne(e), t), s = i == null ? void 0 : i[B];
      if (s && s.base_ === r)
        return e.copy_[t] = r, e.assigned_[t] = !1, !0;
      if (kn(r, i) && (r !== void 0 || we(e.base_, t)))
        return !0;
      lt(e), Ot(e);
    }
    return e.copy_[t] === r && // special case: handle new props with value 'undefined'
    (r !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(r) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = r, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return ft(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, lt(e), Ot(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const r = ne(e), n = Reflect.getOwnPropertyDescriptor(r, t);
    return n && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: n.enumerable,
      value: r[t]
    };
  },
  defineProperty() {
    z(11);
  },
  getPrototypeOf(e) {
    return se(e.base_);
  },
  setPrototypeOf() {
    z(12);
  }
}, Te = {};
Re($t, (e, t) => {
  Te[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Te.deleteProperty = function(e, t) {
  return Te.set.call(this, e, t, void 0);
};
Te.set = function(e, t, r) {
  return $t.set.call(this, e[0], t, r, e[0]);
};
function ft(e, t) {
  const r = e[B];
  return (r ? ne(r) : e)[t];
}
function xn(e, t, r) {
  var i;
  const n = Nr(t, r);
  return n ? "value" in n ? n.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = n.get) == null ? void 0 : i.call(e.draft_)
  ) : void 0;
}
function Nr(e, t) {
  if (!(t in e))
    return;
  let r = se(e);
  for (; r; ) {
    const n = Object.getOwnPropertyDescriptor(r, t);
    if (n)
      return n;
    r = se(r);
  }
}
function Ot(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Ot(e.parent_));
}
function lt(e) {
  e.copy_ || (e.copy_ = St(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Nn = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, r, n) => {
      if (typeof t == "function" && typeof r != "function") {
        const s = r;
        r = t;
        const u = this;
        return function(o = s, ...y) {
          return u.produce(o, (l) => r.call(this, l, ...y));
        };
      }
      typeof r != "function" && z(6), n !== void 0 && typeof n != "function" && z(7);
      let i;
      if (Y(t)) {
        const s = Xt(this), u = Tt(t, void 0);
        let c = !0;
        try {
          i = r(u), c = !1;
        } finally {
          c ? Rt(s) : wt(s);
        }
        return Yt(s, n), Zt(i, s);
      } else if (!t || typeof t != "object") {
        if (i = r(t), i === void 0 && (i = t), i === It && (i = void 0), this.autoFreeze_ && Dt(i, !0), n) {
          const s = [], u = [];
          ue("Patches").generateReplacementPatches_(t, i, s, u), n(s, u);
        }
        return i;
      } else
        z(1, t);
    }, this.produceWithPatches = (t, r) => {
      if (typeof t == "function")
        return (u, ...c) => this.produceWithPatches(u, (o) => t(o, ...c));
      let n, i;
      return [this.produce(t, r, (u, c) => {
        n = u, i = c;
      }), n, i];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Y(e) || z(8), Z(e) && (e = Un(e));
    const t = Xt(this), r = Tt(e, void 0);
    return r[B].isManual_ = !0, wt(t), r;
  }
  finishDraft(e, t) {
    const r = e && e[B];
    (!r || !r.isManual_) && z(9);
    const { scope_: n } = r;
    return Yt(n, t), Zt(void 0, n);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let r;
    for (r = t.length - 1; r >= 0; r--) {
      const i = t[r];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    r > -1 && (t = t.slice(r + 1));
    const n = ue("Patches").applyPatches_;
    return Z(e) ? n(e, t) : this.produce(
      e,
      (i) => n(i, t)
    );
  }
};
function Tt(e, t) {
  const r = Pe(e) ? ue("MapSet").proxyMap_(e, t) : Me(e) ? ue("MapSet").proxySet_(e, t) : qn(e, t);
  return (t ? t.scope_ : xr()).drafts_.push(r), r;
}
function Un(e) {
  return Z(e) || z(10, e), Ur(e);
}
function Ur(e) {
  if (!Y(e) || nt(e))
    return e;
  const t = e[B];
  let r;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, r = St(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    r = St(e, !0);
  return Re(r, (n, i) => {
    qr(r, n, Ur(i));
  }), t && (t.finalized_ = !1), r;
}
function Ln() {
  const t = "replace", r = "add", n = "remove";
  function i(a, d, g, v) {
    switch (a.type_) {
      case 0:
      case 2:
        return u(
          a,
          d,
          g,
          v
        );
      case 1:
        return s(a, d, g, v);
      case 3:
        return c(
          a,
          d,
          g,
          v
        );
    }
  }
  function s(a, d, g, v) {
    let { base_: _, assigned_: S } = a, m = a.copy_;
    m.length < _.length && ([_, m] = [m, _], [g, v] = [v, g]);
    for (let f = 0; f < _.length; f++)
      if (S[f] && m[f] !== _[f]) {
        const p = d.concat([f]);
        g.push({
          op: t,
          path: p,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: h(m[f])
        }), v.push({
          op: t,
          path: p,
          value: h(_[f])
        });
      }
    for (let f = _.length; f < m.length; f++) {
      const p = d.concat([f]);
      g.push({
        op: r,
        path: p,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: h(m[f])
      });
    }
    for (let f = m.length - 1; _.length <= f; --f) {
      const p = d.concat([f]);
      v.push({
        op: n,
        path: p
      });
    }
  }
  function u(a, d, g, v) {
    const { base_: _, copy_: S } = a;
    Re(a.assigned_, (m, f) => {
      const p = ct(_, m), b = ct(S, m), R = f ? we(_, m) ? t : r : n;
      if (p === b && R === t)
        return;
      const C = d.concat(m);
      g.push(R === n ? { op: R, path: C } : { op: R, path: C, value: b }), v.push(
        R === r ? { op: n, path: C } : R === n ? { op: r, path: C, value: h(p) } : { op: t, path: C, value: h(p) }
      );
    });
  }
  function c(a, d, g, v) {
    let { base_: _, copy_: S } = a, m = 0;
    _.forEach((f) => {
      if (!S.has(f)) {
        const p = d.concat([m]);
        g.push({
          op: n,
          path: p,
          value: f
        }), v.unshift({
          op: r,
          path: p,
          value: f
        });
      }
      m++;
    }), m = 0, S.forEach((f) => {
      if (!_.has(f)) {
        const p = d.concat([m]);
        g.push({
          op: r,
          path: p,
          value: f
        }), v.unshift({
          op: n,
          path: p,
          value: f
        });
      }
      m++;
    });
  }
  function o(a, d, g, v) {
    g.push({
      op: t,
      path: [],
      value: d === It ? void 0 : d
    }), v.push({
      op: t,
      path: [],
      value: a
    });
  }
  function y(a, d) {
    return d.forEach((g) => {
      const { path: v, op: _ } = g;
      let S = a;
      for (let b = 0; b < v.length - 1; b++) {
        const R = ae(S);
        let C = v[b];
        typeof C != "string" && typeof C != "number" && (C = "" + C), (R === 0 || R === 1) && (C === "__proto__" || C === "constructor") && z(19), typeof S == "function" && C === "prototype" && z(19), S = ct(S, C), typeof S != "object" && z(18, v.join("/"));
      }
      const m = ae(S), f = l(g.value), p = v[v.length - 1];
      switch (_) {
        case t:
          switch (m) {
            case 2:
              return S.set(p, f);
            case 3:
              z(16);
            default:
              return S[p] = f;
          }
        case r:
          switch (m) {
            case 1:
              return p === "-" ? S.push(f) : S.splice(p, 0, f);
            case 2:
              return S.set(p, f);
            case 3:
              return S.add(f);
            default:
              return S[p] = f;
          }
        case n:
          switch (m) {
            case 1:
              return S.splice(p, 1);
            case 2:
              return S.delete(p);
            case 3:
              return S.delete(g.value);
            default:
              return delete S[p];
          }
        default:
          z(17, _);
      }
    }), a;
  }
  function l(a) {
    if (!Y(a))
      return a;
    if (Array.isArray(a))
      return a.map(l);
    if (Pe(a))
      return new Map(
        Array.from(a.entries()).map(([g, v]) => [g, l(v)])
      );
    if (Me(a))
      return new Set(Array.from(a).map(l));
    const d = Object.create(se(a));
    for (const g in a)
      d[g] = l(a[g]);
    return we(a, ve) && (d[ve] = a[ve]), d;
  }
  function h(a) {
    return Z(a) ? l(a) : a;
  }
  In("Patches", {
    applyPatches_: y,
    generatePatches_: i,
    generateReplacementPatches_: o
  });
}
var H = new Nn(), ke = H.produce, Lr = H.produceWithPatches.bind(
  H
);
H.setAutoFreeze.bind(H);
H.setUseStrictShallowCopy.bind(H);
var er = H.applyPatches.bind(H);
H.createDraft.bind(H);
H.finishDraft.bind(H);
function zn(e, t = `expected a function, instead received ${typeof e}`) {
  if (typeof e != "function")
    throw new TypeError(t);
}
function Qn(e, t = `expected an object, instead received ${typeof e}`) {
  if (typeof e != "object")
    throw new TypeError(t);
}
function Kn(e, t = "expected all items to be functions, instead received the following types: ") {
  if (!e.every((r) => typeof r == "function")) {
    const r = e.map(
      (n) => typeof n == "function" ? `function ${n.name || "unnamed"}()` : typeof n
    ).join(", ");
    throw new TypeError(`${t}[${r}]`);
  }
}
var tr = (e) => Array.isArray(e) ? e : [e];
function Wn(e) {
  const t = Array.isArray(e[0]) ? e[0] : e;
  return Kn(
    t,
    "createSelector expects all input-selectors to be functions, but received the following types: "
  ), t;
}
function Bn(e, t) {
  const r = [], { length: n } = e;
  for (let i = 0; i < n; i++)
    r.push(e[i].apply(null, t));
  return r;
}
var Hn = class {
  constructor(e) {
    this.value = e;
  }
  deref() {
    return this.value;
  }
}, Vn = typeof WeakRef < "u" ? WeakRef : Hn, Gn = 0, rr = 1;
function Ne() {
  return {
    s: Gn,
    v: void 0,
    o: null,
    p: null
  };
}
function je(e, t = {}) {
  let r = Ne();
  const { resultEqualityCheck: n } = t;
  let i, s = 0;
  function u() {
    var h;
    let c = r;
    const { length: o } = arguments;
    for (let a = 0, d = o; a < d; a++) {
      const g = arguments[a];
      if (typeof g == "function" || typeof g == "object" && g !== null) {
        let v = c.o;
        v === null && (c.o = v = /* @__PURE__ */ new WeakMap());
        const _ = v.get(g);
        _ === void 0 ? (c = Ne(), v.set(g, c)) : c = _;
      } else {
        let v = c.p;
        v === null && (c.p = v = /* @__PURE__ */ new Map());
        const _ = v.get(g);
        _ === void 0 ? (c = Ne(), v.set(g, c)) : c = _;
      }
    }
    const y = c;
    let l;
    if (c.s === rr)
      l = c.v;
    else if (l = e.apply(null, arguments), s++, n) {
      const a = ((h = i == null ? void 0 : i.deref) == null ? void 0 : h.call(i)) ?? i;
      a != null && n(a, l) && (l = a, s !== 0 && s--), i = typeof l == "object" && l !== null || typeof l == "function" ? new Vn(l) : l;
    }
    return y.s = rr, y.v = l, l;
  }
  return u.clearCache = () => {
    r = Ne(), u.resetResultsCount();
  }, u.resultsCount = () => s, u.resetResultsCount = () => {
    s = 0;
  }, u;
}
function Jn(e, ...t) {
  const r = typeof e == "function" ? {
    memoize: e,
    memoizeOptions: t
  } : e, n = (...i) => {
    let s = 0, u = 0, c, o = {}, y = i.pop();
    typeof y == "object" && (o = y, y = i.pop()), zn(
      y,
      `createSelector expects an output function after the inputs, but received: [${typeof y}]`
    );
    const l = {
      ...r,
      ...o
    }, {
      memoize: h,
      memoizeOptions: a = [],
      argsMemoize: d = je,
      argsMemoizeOptions: g = [],
      devModeChecks: v = {}
    } = l, _ = tr(a), S = tr(g), m = Wn(i), f = h(function() {
      return s++, y.apply(
        null,
        arguments
      );
    }, ..._), p = d(function() {
      u++;
      const R = Bn(
        m,
        arguments
      );
      return c = f.apply(null, R), c;
    }, ...S);
    return Object.assign(p, {
      resultFunc: y,
      memoizedResultFunc: f,
      dependencies: m,
      dependencyRecomputations: () => u,
      resetDependencyRecomputations: () => {
        u = 0;
      },
      lastResult: () => c,
      recomputations: () => s,
      resetRecomputations: () => {
        s = 0;
      },
      memoize: h,
      argsMemoize: d
    });
  };
  return Object.assign(n, {
    withTypes: () => n
  }), n;
}
var ye = /* @__PURE__ */ Jn(je), Yn = Object.assign(
  (e, t = ye) => {
    Qn(
      e,
      `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof e}`
    );
    const r = Object.keys(e), n = r.map(
      (s) => e[s]
    );
    return t(
      n,
      (...s) => s.reduce((u, c, o) => (u[r[o]] = c, u), {})
    );
  },
  { withTypes: () => Yn }
), Xn = (e) => e && typeof e.match == "function";
function A(e, t) {
  function r(...n) {
    if (t) {
      let i = t(...n);
      if (!i)
        throw new Error(V(0));
      return {
        type: e,
        payload: i.payload,
        ..."meta" in i && {
          meta: i.meta
        },
        ..."error" in i && {
          error: i.error
        }
      };
    }
    return {
      type: e,
      payload: n[0]
    };
  }
  return r.toString = () => `${e}`, r.type = e, r.match = (n) => Dr(n) && n.type === e, r;
}
function nr(e) {
  return Y(e) ? ke(e, () => {
  }) : e;
}
function ir(e, t, r) {
  if (e.has(t)) {
    let i = e.get(t);
    return r.update && (i = r.update(i, t, e), e.set(t, i)), i;
  }
  if (!r.insert) throw new Error(V(10));
  const n = r.insert(t, e);
  return e.set(t, n), n;
}
var _e = "RTK_autoBatch", ge = () => (e) => ({
  payload: e,
  meta: {
    [_e]: !0
  }
});
function zr(e) {
  const t = {}, r = [];
  let n;
  const i = {
    addCase(s, u) {
      const c = typeof s == "string" ? s : s.type;
      if (!c)
        throw new Error(V(28));
      if (c in t)
        throw new Error(V(29));
      return t[c] = u, i;
    },
    addMatcher(s, u) {
      return r.push({
        matcher: s,
        reducer: u
      }), i;
    },
    addDefaultCase(s) {
      return n = s, i;
    }
  };
  return e(i), [t, r, n];
}
function Zn(e) {
  return typeof e == "function";
}
function Fe(e, t) {
  let [r, n, i] = zr(t), s;
  if (Zn(e))
    s = () => nr(e());
  else {
    const c = nr(e);
    s = () => c;
  }
  function u(c = s(), o) {
    let y = [r[o.type], ...n.filter(({
      matcher: l
    }) => l(o)).map(({
      reducer: l
    }) => l)];
    return y.filter((l) => !!l).length === 0 && (y = [i]), y.reduce((l, h) => {
      if (h)
        if (Z(l)) {
          const d = h(l, o);
          return d === void 0 ? l : d;
        } else {
          if (Y(l))
            return ke(l, (a) => h(a, o));
          {
            const a = h(l, o);
            if (a === void 0) {
              if (l === null)
                return l;
              throw new Error(V(9));
            }
            return a;
          }
        }
      return l;
    }, c);
  }
  return u.getInitialState = s, u;
}
var Qr = (e, t) => Xn(e) ? e.match(t) : e(t);
function j(...e) {
  return (t) => e.some((r) => Qr(r, t));
}
function be(...e) {
  return (t) => e.every((r) => Qr(r, t));
}
function it(e, t) {
  if (!e || !e.meta) return !1;
  const r = typeof e.meta.requestId == "string", n = t.indexOf(e.meta.requestStatus) > -1;
  return r && n;
}
function Ie(e) {
  return typeof e[0] == "function" && "pending" in e[0] && "fulfilled" in e[0] && "rejected" in e[0];
}
function qt(...e) {
  return e.length === 0 ? (t) => it(t, ["pending"]) : Ie(e) ? j(...e.map((t) => t.pending)) : qt()(e[0]);
}
function pe(...e) {
  return e.length === 0 ? (t) => it(t, ["rejected"]) : Ie(e) ? j(...e.map((t) => t.rejected)) : pe()(e[0]);
}
function ot(...e) {
  const t = (r) => r && r.meta && r.meta.rejectedWithValue;
  return e.length === 0 ? be(pe(...e), t) : Ie(e) ? be(pe(...e), t) : ot()(e[0]);
}
function re(...e) {
  return e.length === 0 ? (t) => it(t, ["fulfilled"]) : Ie(e) ? j(...e.map((t) => t.fulfilled)) : re()(e[0]);
}
function Et(...e) {
  return e.length === 0 ? (t) => it(t, ["pending", "fulfilled", "rejected"]) : Ie(e) ? j(...e.flatMap((t) => [t.pending, t.rejected, t.fulfilled])) : Et()(e[0]);
}
var jn = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW", Kr = (e = 21) => {
  let t = "", r = e;
  for (; r--; )
    t += jn[Math.random() * 64 | 0];
  return t;
}, ei = ["name", "message", "stack", "code"], dt = class {
  constructor(e, t) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    at(this, "_type");
    this.payload = e, this.meta = t;
  }
}, or = class {
  constructor(e, t) {
    /*
    type-only property to distinguish between RejectWithValue and FulfillWithMeta
    does not exist at runtime
    */
    at(this, "_type");
    this.payload = e, this.meta = t;
  }
}, ti = (e) => {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const r of ei)
      typeof e[r] == "string" && (t[r] = e[r]);
    return t;
  }
  return {
    message: String(e)
  };
}, et = /* @__PURE__ */ (() => {
  function e(t, r, n) {
    const i = A(t + "/fulfilled", (o, y, l, h) => ({
      payload: o,
      meta: {
        ...h || {},
        arg: l,
        requestId: y,
        requestStatus: "fulfilled"
      }
    })), s = A(t + "/pending", (o, y, l) => ({
      payload: void 0,
      meta: {
        ...l || {},
        arg: y,
        requestId: o,
        requestStatus: "pending"
      }
    })), u = A(t + "/rejected", (o, y, l, h, a) => ({
      payload: h,
      error: (n && n.serializeError || ti)(o || "Rejected"),
      meta: {
        ...a || {},
        arg: l,
        requestId: y,
        rejectedWithValue: !!h,
        requestStatus: "rejected",
        aborted: (o == null ? void 0 : o.name) === "AbortError",
        condition: (o == null ? void 0 : o.name) === "ConditionError"
      }
    }));
    function c(o) {
      return (y, l, h) => {
        const a = n != null && n.idGenerator ? n.idGenerator(o) : Kr(), d = new AbortController();
        let g, v;
        function _(m) {
          v = m, d.abort();
        }
        const S = async function() {
          var p, b;
          let m;
          try {
            let R = (p = n == null ? void 0 : n.condition) == null ? void 0 : p.call(n, o, {
              getState: l,
              extra: h
            });
            if (ni(R) && (R = await R), R === !1 || d.signal.aborted)
              throw {
                name: "ConditionError",
                message: "Aborted due to condition callback returning false."
              };
            const C = new Promise((w, O) => {
              g = () => {
                O({
                  name: "AbortError",
                  message: v || "Aborted"
                });
              }, d.signal.addEventListener("abort", g);
            });
            y(s(a, o, (b = n == null ? void 0 : n.getPendingMeta) == null ? void 0 : b.call(n, {
              requestId: a,
              arg: o
            }, {
              getState: l,
              extra: h
            }))), m = await Promise.race([C, Promise.resolve(r(o, {
              dispatch: y,
              getState: l,
              extra: h,
              requestId: a,
              signal: d.signal,
              abort: _,
              rejectWithValue: (w, O) => new dt(w, O),
              fulfillWithValue: (w, O) => new or(w, O)
            })).then((w) => {
              if (w instanceof dt)
                throw w;
              return w instanceof or ? i(w.payload, a, o, w.meta) : i(w, a, o);
            })]);
          } catch (R) {
            m = R instanceof dt ? u(null, a, o, R.payload, R.meta) : u(R, a, o);
          } finally {
            g && d.signal.removeEventListener("abort", g);
          }
          return n && !n.dispatchConditionRejection && u.match(m) && m.meta.condition || y(m), m;
        }();
        return Object.assign(S, {
          abort: _,
          requestId: a,
          arg: o,
          unwrap() {
            return S.then(ri);
          }
        });
      };
    }
    return Object.assign(c, {
      pending: s,
      rejected: u,
      fulfilled: i,
      settled: j(u, i),
      typePrefix: t
    });
  }
  return e.withTypes = () => e, e;
})();
function ri(e) {
  if (e.meta && e.meta.rejectedWithValue)
    throw e.payload;
  if (e.error)
    throw e.error;
  return e.payload;
}
function ni(e) {
  return e !== null && typeof e == "object" && typeof e.then == "function";
}
var ii = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
function oi(e, t) {
  return `${e}/${t}`;
}
function si({
  creators: e
} = {}) {
  var r;
  const t = (r = e == null ? void 0 : e.asyncThunk) == null ? void 0 : r[ii];
  return function(i) {
    const {
      name: s,
      reducerPath: u = s
    } = i;
    if (!s)
      throw new Error(V(11));
    typeof process < "u";
    const c = (typeof i.reducers == "function" ? i.reducers(ui()) : i.reducers) || {}, o = Object.keys(c), y = {
      sliceCaseReducersByName: {},
      sliceCaseReducersByType: {},
      actionCreators: {},
      sliceMatchers: []
    }, l = {
      addCase(f, p) {
        const b = typeof f == "string" ? f : f.type;
        if (!b)
          throw new Error(V(12));
        if (b in y.sliceCaseReducersByType)
          throw new Error(V(13));
        return y.sliceCaseReducersByType[b] = p, l;
      },
      addMatcher(f, p) {
        return y.sliceMatchers.push({
          matcher: f,
          reducer: p
        }), l;
      },
      exposeAction(f, p) {
        return y.actionCreators[f] = p, l;
      },
      exposeCaseReducer(f, p) {
        return y.sliceCaseReducersByName[f] = p, l;
      }
    };
    o.forEach((f) => {
      const p = c[f], b = {
        reducerName: f,
        type: oi(s, f),
        createNotation: typeof i.reducers == "function"
      };
      fi(p) ? di(b, p, l, t) : ci(b, p, l);
    });
    function h() {
      const [f = {}, p = [], b = void 0] = typeof i.extraReducers == "function" ? zr(i.extraReducers) : [i.extraReducers], R = {
        ...f,
        ...y.sliceCaseReducersByType
      };
      return Fe(i.initialState, (C) => {
        for (let w in R)
          C.addCase(w, R[w]);
        for (let w of y.sliceMatchers)
          C.addMatcher(w.matcher, w.reducer);
        for (let w of p)
          C.addMatcher(w.matcher, w.reducer);
        b && C.addDefaultCase(b);
      });
    }
    const a = (f) => f, d = /* @__PURE__ */ new Map();
    let g;
    function v(f, p) {
      return g || (g = h()), g(f, p);
    }
    function _() {
      return g || (g = h()), g.getInitialState();
    }
    function S(f, p = !1) {
      function b(C) {
        let w = C[f];
        return typeof w > "u" && p && (w = _()), w;
      }
      function R(C = a) {
        const w = ir(d, p, {
          insert: () => /* @__PURE__ */ new WeakMap()
        });
        return ir(w, C, {
          insert: () => {
            const O = {};
            for (const [T, E] of Object.entries(i.selectors ?? {}))
              O[T] = ai(E, C, _, p);
            return O;
          }
        });
      }
      return {
        reducerPath: f,
        getSelectors: R,
        get selectors() {
          return R(b);
        },
        selectSlice: b
      };
    }
    const m = {
      name: s,
      reducer: v,
      actions: y.actionCreators,
      caseReducers: y.sliceCaseReducersByName,
      getInitialState: _,
      ...S(u),
      injectInto(f, {
        reducerPath: p,
        ...b
      } = {}) {
        const R = p ?? u;
        return f.inject({
          reducerPath: R,
          reducer: v
        }, b), {
          ...m,
          ...S(R, !0)
        };
      }
    };
    return m;
  };
}
function ai(e, t, r, n) {
  function i(s, ...u) {
    let c = t(s);
    return typeof c > "u" && n && (c = r()), e(c, ...u);
  }
  return i.unwrapped = e, i;
}
var ie = /* @__PURE__ */ si();
function ui() {
  function e(t, r) {
    return {
      _reducerDefinitionType: "asyncThunk",
      payloadCreator: t,
      ...r
    };
  }
  return e.withTypes = () => e, {
    reducer(t) {
      return Object.assign({
        // hack so the wrapping function has the same name as the original
        // we need to create a wrapper so the `reducerDefinitionType` is not assigned to the original
        [t.name](...r) {
          return t(...r);
        }
      }[t.name], {
        _reducerDefinitionType: "reducer"
        /* reducer */
      });
    },
    preparedReducer(t, r) {
      return {
        _reducerDefinitionType: "reducerWithPrepare",
        prepare: t,
        reducer: r
      };
    },
    asyncThunk: e
  };
}
function ci({
  type: e,
  reducerName: t,
  createNotation: r
}, n, i) {
  let s, u;
  if ("reducer" in n) {
    if (r && !li(n))
      throw new Error(V(17));
    s = n.reducer, u = n.prepare;
  } else
    s = n;
  i.addCase(e, s).exposeCaseReducer(t, s).exposeAction(t, u ? A(e, u) : A(e));
}
function fi(e) {
  return e._reducerDefinitionType === "asyncThunk";
}
function li(e) {
  return e._reducerDefinitionType === "reducerWithPrepare";
}
function di({
  type: e,
  reducerName: t
}, r, n, i) {
  if (!i)
    throw new Error(V(18));
  const {
    payloadCreator: s,
    fulfilled: u,
    pending: c,
    rejected: o,
    settled: y,
    options: l
  } = r, h = i(e, s, l);
  n.exposeAction(t, h), u && n.addCase(h.fulfilled, u), c && n.addCase(h.pending, c), o && n.addCase(h.rejected, o), y && n.addMatcher(h.settled, y), n.exposeCaseReducer(t, {
    fulfilled: u || Ue,
    pending: c || Ue,
    rejected: o || Ue,
    settled: y || Ue
  });
}
function Ue() {
}
function V(e) {
  return `Minified Redux Toolkit error #${e}; visit https://redux-toolkit.js.org/Errors?code=${e} for the full message or use the non-minified dev environment for full errors. `;
}
function pi(e) {
  return !(!e || typeof e != "object" || !("function" in e) || !("index" in e));
}
function yi(e) {
  return !(!e || typeof e != "object" || !("file_name" in e) || typeof e.file_name != "string" || !("file_action" in e) || typeof e.file_action != "string" || !("line1" in e) || typeof e.line1 != "number" || !("line2" in e) || typeof e.line2 != "number" || !("lines_remove" in e) || typeof e.lines_remove != "string" || !("lines_add" in e) || typeof e.lines_add != "string");
}
function hi(e) {
  return e.role === "user";
}
function Ia(e) {
  return e.role === "context_file";
}
function xt(e) {
  return e.role === "assistant";
}
function tt(e) {
  return e.role === "tool";
}
function gi(e) {
  return e.role === "diff";
}
function sr(e) {
  if (!xt(e)) return !1;
  const t = e.tool_calls;
  return t ? t.every(pi) : !1;
}
function Da(e) {
  return e.role === "plain_text";
}
function mi(e) {
  return e.role === "cd_instruction";
}
function _i(e) {
  return !(!e || typeof e != "object" || "role" in e && e.role !== null && e.role !== "assistant" || !("content" in e) || typeof e.content != "string");
}
function $a(e) {
  return !e || typeof e != "object" || !("role" in e) ? !1 : e.role === "context_file";
}
function qa(e) {
  return !e || typeof e != "object" || !("tool_calls" in e) || e.tool_calls === null ? !1 : Array.isArray(e.tool_calls);
}
function xa(e) {
  return !e || typeof e != "object" || !("id" in e) || !("content" in e) || !("role" in e) ? !1 : e.role === "user" || e.role === "context_file" || e.role === "context_memory";
}
function Na(e) {
  return !e || typeof e != "object" || !("content" in e) || !("role" in e) || !("tool_call_id" in e) ? !1 : e.role === "tool";
}
function Ua(e) {
  return !e || typeof e != "object" || !("content" in e) || !("role" in e) ? !1 : e.role === "diff";
}
function La(e) {
  return !e || typeof e != "object" || !("role" in e) ? !1 : e.role === "plain_text";
}
function vi(e) {
  return "choices" in e;
}
function At(e) {
  return !(!e || typeof e != "object" || !("memid" in e) || typeof e.memid != "string");
}
function ar(e) {
  return !(!e || typeof e != "object" || !("files_unprocessed" in e) || typeof e.files_unprocessed != "number" || !("files_total" in e) || typeof e.files_total != "number" || !("requests_made_since_start" in e) || typeof e.requests_made_since_start != "number" || !("vectors_made_since_start" in e) || typeof e.vectors_made_since_start != "number" || !("db_size" in e) || typeof e.db_size != "number" || !("db_cache_size" in e) || typeof e.db_cache_size != "number" || !("state" in e) || typeof e.state != "string" || !("queue_additions" in e) || typeof e.queue_additions != "boolean" || !("vecdb_max_files_hit" in e) || typeof e.vecdb_max_files_hit != "boolean" || !("vecdb_errors" in e) || typeof e.vecdb_errors != "object");
}
const Wr = "/v1/chat", bi = "/v1/caps", Si = "/v1/get-dashboard-plots", Ci = "/v1/at-command-completion", Ri = "/v1/at-command-preview", wi = "/v1/customization", Oi = "/v1/tools", Ti = "/v1/tools-check-if-confirmation-needed", ur = "/v1/file_edit_tool_dry_run", Le = "/v1/config-path", Ei = "/v1/fullpath", cr = "/v1/ping", Ai = "/v1/links", Pi = "/v1/git-commit", Mi = "/v1/integrations", ki = "/v1/integration-get", Fi = "/v1/integration-save", Ii = "/v1/integration-delete", ze = "/v1/docker-container-list", Di = "/v1/docker-container-action", $i = "/v1/telemetry-chat", pt = "/v1/telemetry-network", qi = "/v1/mem-sub", xi = "/v1/mem-add", Ni = "/v1/mem-erase", Ui = "/v1/mem-update-used", Li = "/v1/mem-upd", zi = "/v1/trajectory-save";
var Br = /* @__PURE__ */ ((e) => (e.uninitialized = "uninitialized", e.pending = "pending", e.fulfilled = "fulfilled", e.rejected = "rejected", e))(Br || {});
function Qi(e) {
  return {
    status: e,
    isUninitialized: e === "uninitialized",
    isLoading: e === "pending",
    isSuccess: e === "fulfilled",
    isError: e === "rejected"
    /* rejected */
  };
}
var fr = te;
function Hr(e, t) {
  if (e === t || !(fr(e) && fr(t) || Array.isArray(e) && Array.isArray(t)))
    return t;
  const r = Object.keys(t), n = Object.keys(e);
  let i = r.length === n.length;
  const s = Array.isArray(t) ? [] : {};
  for (const u of r)
    s[u] = Hr(e[u], t[u]), i && (i = e[u] === s[u]);
  return i ? e : s;
}
function de(e) {
  let t = 0;
  for (const r in e)
    t++;
  return t;
}
var lr = (e) => [].concat(...e);
function Ki(e) {
  return new RegExp("(^|:)//").test(e);
}
function Wi() {
  return typeof document > "u" ? !0 : document.visibilityState !== "hidden";
}
function dr(e) {
  return e != null;
}
function Bi() {
  return typeof navigator > "u" || navigator.onLine === void 0 ? !0 : navigator.onLine;
}
var Hi = (e) => e.replace(/\/$/, ""), Vi = (e) => e.replace(/^\//, "");
function Gi(e, t) {
  if (!e)
    return t;
  if (!t)
    return e;
  if (Ki(t))
    return t;
  const r = e.endsWith("/") || !t.startsWith("?") ? "/" : "";
  return e = Hi(e), t = Vi(t), `${e}${r}${t}`;
}
var pr = (...e) => fetch(...e), Ji = (e) => e.status >= 200 && e.status <= 299, Yi = (e) => (
  /*applicat*/
  /ion\/(vnd\.api\+)?json/.test(e.get("content-type") || "")
);
function yr(e) {
  if (!te(e))
    return e;
  const t = {
    ...e
  };
  for (const [r, n] of Object.entries(t))
    n === void 0 && delete t[r];
  return t;
}
function G({
  baseUrl: e,
  prepareHeaders: t = (h) => h,
  fetchFn: r = pr,
  paramsSerializer: n,
  isJsonContentType: i = Yi,
  jsonContentType: s = "application/json",
  jsonReplacer: u,
  timeout: c,
  responseHandler: o,
  validateStatus: y,
  ...l
} = {}) {
  return typeof fetch > "u" && r === pr && console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments."), async (a, d) => {
    const {
      signal: g,
      getState: v,
      extra: _,
      endpoint: S,
      forced: m,
      type: f
    } = d;
    let p, {
      url: b,
      headers: R = new Headers(l.headers),
      params: C = void 0,
      responseHandler: w = o ?? "json",
      validateStatus: O = y ?? Ji,
      timeout: T = c,
      ...E
    } = typeof a == "string" ? {
      url: a
    } : a, P = {
      ...l,
      signal: g,
      ...E
    };
    R = new Headers(yr(R)), P.headers = await t(R, {
      getState: v,
      extra: _,
      endpoint: S,
      forced: m,
      type: f
    }) || R;
    const M = (N) => typeof N == "object" && (te(N) || Array.isArray(N) || typeof N.toJSON == "function");
    if (!P.headers.has("content-type") && M(P.body) && P.headers.set("content-type", s), M(P.body) && i(P.headers) && (P.body = JSON.stringify(P.body, u)), C) {
      const N = ~b.indexOf("?") ? "&" : "?", U = n ? n(C) : new URLSearchParams(yr(C));
      b += N + U;
    }
    b = Gi(e, b);
    const k = new Request(b, P);
    p = {
      request: new Request(b, P)
    };
    let x, Q = !1, q = T && setTimeout(() => {
      Q = !0, d.abort();
    }, T);
    try {
      x = await r(k);
    } catch (N) {
      return {
        error: {
          status: Q ? "TIMEOUT_ERROR" : "FETCH_ERROR",
          error: String(N)
        },
        meta: p
      };
    } finally {
      q && clearTimeout(q);
    }
    const L = x.clone();
    p.response = L;
    let D, K = "";
    try {
      let N;
      if (await Promise.all([
        h(x, w).then((U) => D = U, (U) => N = U),
        // see https://github.com/node-fetch/node-fetch/issues/665#issuecomment-538995182
        // we *have* to "use up" both streams at the same time or they will stop running in node-fetch scenarios
        L.text().then((U) => K = U, () => {
        })
      ]), N) throw N;
    } catch (N) {
      return {
        error: {
          status: "PARSING_ERROR",
          originalStatus: x.status,
          data: K,
          error: String(N)
        },
        meta: p
      };
    }
    return O(x, D) ? {
      data: D,
      meta: p
    } : {
      error: {
        status: x.status,
        data: D
      },
      meta: p
    };
  };
  async function h(a, d) {
    if (typeof d == "function")
      return d(a);
    if (d === "content-type" && (d = i(a.headers) ? "json" : "text"), d === "json") {
      const g = await a.text();
      return g.length ? JSON.parse(g) : null;
    }
    return a.text();
  }
}
var hr = class {
  constructor(e, t = void 0) {
    this.value = e, this.meta = t;
  }
}, Nt = /* @__PURE__ */ A("__rtkq/focused"), Vr = /* @__PURE__ */ A("__rtkq/unfocused"), Ut = /* @__PURE__ */ A("__rtkq/online"), Gr = /* @__PURE__ */ A("__rtkq/offline");
function Jr(e) {
  return e.type === "query";
}
function Xi(e) {
  return e.type === "mutation";
}
function Lt(e, t, r, n, i, s) {
  return Zi(e) ? e(t, r, n, i).map(Pt).map(s) : Array.isArray(e) ? e.map(Pt).map(s) : [];
}
function Zi(e) {
  return typeof e == "function";
}
function Pt(e) {
  return typeof e == "string" ? {
    type: e
  } : e;
}
function ji(e, t) {
  return e.catch(t);
}
var Ee = Symbol("forceQueryFn"), Mt = (e) => typeof e[Ee] == "function";
function eo({
  serializeQueryArgs: e,
  queryThunk: t,
  mutationThunk: r,
  api: n,
  context: i
}) {
  const s = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), {
    unsubscribeQueryResult: c,
    removeMutationResult: o,
    updateSubscriptionOptions: y
  } = n.internalActions;
  return {
    buildInitiateQuery: g,
    buildInitiateMutation: v,
    getRunningQueryThunk: l,
    getRunningMutationThunk: h,
    getRunningQueriesThunk: a,
    getRunningMutationsThunk: d
  };
  function l(_, S) {
    return (m) => {
      var b;
      const f = i.endpointDefinitions[_], p = e({
        queryArgs: S,
        endpointDefinition: f,
        endpointName: _
      });
      return (b = s.get(m)) == null ? void 0 : b[p];
    };
  }
  function h(_, S) {
    return (m) => {
      var f;
      return (f = u.get(m)) == null ? void 0 : f[S];
    };
  }
  function a() {
    return (_) => Object.values(s.get(_) || {}).filter(dr);
  }
  function d() {
    return (_) => Object.values(u.get(_) || {}).filter(dr);
  }
  function g(_, S) {
    const m = (f, {
      subscribe: p = !0,
      forceRefetch: b,
      subscriptionOptions: R,
      [Ee]: C,
      ...w
    } = {}) => (O, T) => {
      var N;
      const E = e({
        queryArgs: f,
        endpointDefinition: S,
        endpointName: _
      }), P = t({
        ...w,
        type: "query",
        subscribe: p,
        forceRefetch: b,
        subscriptionOptions: R,
        endpointName: _,
        originalArgs: f,
        queryCacheKey: E,
        [Ee]: C
      }), M = n.endpoints[_].select(f), k = O(P), $ = M(T()), {
        requestId: x,
        abort: Q
      } = k, q = $.requestId !== x, L = (N = s.get(O)) == null ? void 0 : N[E], D = () => M(T()), K = Object.assign(C ? (
        // a query has been forced (upsertQueryData)
        // -> we want to resolve it once data has been written with the data that will be written
        k.then(D)
      ) : q && !L ? (
        // a query has been skipped due to a condition and we do not have any currently running query
        // -> we want to resolve it immediately with the current data
        Promise.resolve($)
      ) : (
        // query just started or one is already in flight
        // -> wait for the running query, then resolve with data from after that
        Promise.all([L, k]).then(D)
      ), {
        arg: f,
        requestId: x,
        subscriptionOptions: R,
        queryCacheKey: E,
        abort: Q,
        async unwrap() {
          const U = await K;
          if (U.isError)
            throw U.error;
          return U.data;
        },
        refetch: () => O(m(f, {
          subscribe: !1,
          forceRefetch: !0
        })),
        unsubscribe() {
          p && O(c({
            queryCacheKey: E,
            requestId: x
          }));
        },
        updateSubscriptionOptions(U) {
          K.subscriptionOptions = U, O(y({
            endpointName: _,
            requestId: x,
            queryCacheKey: E,
            options: U
          }));
        }
      });
      if (!L && !q && !C) {
        const U = s.get(O) || {};
        U[E] = K, s.set(O, U), K.then(() => {
          delete U[E], de(U) || s.delete(O);
        });
      }
      return K;
    };
    return m;
  }
  function v(_) {
    return (S, {
      track: m = !0,
      fixedCacheKey: f
    } = {}) => (p, b) => {
      const R = r({
        type: "mutation",
        endpointName: _,
        originalArgs: S,
        track: m,
        fixedCacheKey: f
      }), C = p(R), {
        requestId: w,
        abort: O,
        unwrap: T
      } = C, E = ji(C.unwrap().then(($) => ({
        data: $
      })), ($) => ({
        error: $
      })), P = () => {
        p(o({
          requestId: w,
          fixedCacheKey: f
        }));
      }, M = Object.assign(E, {
        arg: C.arg,
        requestId: w,
        abort: O,
        unwrap: T,
        reset: P
      }), k = u.get(p) || {};
      return u.set(p, k), k[w] = M, M.then(() => {
        delete k[w], de(k) || u.delete(p);
      }), f && (k[f] = M, M.then(() => {
        k[f] === M && (delete k[f], de(k) || u.delete(p));
      })), M;
    };
  }
}
function gr(e) {
  return e;
}
function to({
  reducerPath: e,
  baseQuery: t,
  context: {
    endpointDefinitions: r
  },
  serializeQueryArgs: n,
  api: i,
  assertTagType: s
}) {
  const u = (m, f, p, b) => (R, C) => {
    const w = r[m], O = n({
      queryArgs: f,
      endpointDefinition: w,
      endpointName: m
    });
    if (R(i.internalActions.queryResultPatched({
      queryCacheKey: O,
      patches: p
    })), !b)
      return;
    const T = i.endpoints[m].select(f)(
      // Work around TS 4.1 mismatch
      C()
    ), E = Lt(w.providesTags, T.data, void 0, f, {}, s);
    R(i.internalActions.updateProvidedBy({
      queryCacheKey: O,
      providedTags: E
    }));
  }, c = (m, f, p, b = !0) => (R, C) => {
    const O = i.endpoints[m].select(f)(
      // Work around TS 4.1 mismatch
      C()
    ), T = {
      patches: [],
      inversePatches: [],
      undo: () => R(i.util.patchQueryData(m, f, T.inversePatches, b))
    };
    if (O.status === "uninitialized")
      return T;
    let E;
    if ("data" in O)
      if (Y(O.data)) {
        const [P, M, k] = Lr(O.data, p);
        T.patches.push(...M), T.inversePatches.push(...k), E = P;
      } else
        E = p(O.data), T.patches.push({
          op: "replace",
          path: [],
          value: E
        }), T.inversePatches.push({
          op: "replace",
          path: [],
          value: O.data
        });
    return T.patches.length === 0 || R(i.util.patchQueryData(m, f, T.patches, b)), T;
  }, o = (m, f, p) => (b) => b(i.endpoints[m].initiate(f, {
    subscribe: !1,
    forceRefetch: !0,
    [Ee]: () => ({
      data: p
    })
  })), y = async (m, {
    signal: f,
    abort: p,
    rejectWithValue: b,
    fulfillWithValue: R,
    dispatch: C,
    getState: w,
    extra: O
  }) => {
    const T = r[m.endpointName];
    try {
      let E = gr, P;
      const M = {
        signal: f,
        abort: p,
        dispatch: C,
        getState: w,
        extra: O,
        endpoint: m.endpointName,
        type: m.type,
        forced: m.type === "query" ? l(m, w()) : void 0
      }, k = m.type === "query" ? m[Ee] : void 0;
      if (k ? P = k() : T.query ? (P = await t(T.query(m.originalArgs), M, T.extraOptions), T.transformResponse && (E = T.transformResponse)) : P = await T.queryFn(m.originalArgs, M, T.extraOptions, ($) => t($, M, T.extraOptions)), typeof process < "u", P.error) throw new hr(P.error, P.meta);
      return R(await E(P.data, P.meta, m.originalArgs), {
        fulfilledTimeStamp: Date.now(),
        baseQueryMeta: P.meta,
        [_e]: !0
      });
    } catch (E) {
      let P = E;
      if (P instanceof hr) {
        let M = gr;
        T.query && T.transformErrorResponse && (M = T.transformErrorResponse);
        try {
          return b(await M(P.value, P.meta, m.originalArgs), {
            baseQueryMeta: P.meta,
            [_e]: !0
          });
        } catch (k) {
          P = k;
        }
      }
      throw typeof process < "u", console.error(P), P;
    }
  };
  function l(m, f) {
    var w, O, T;
    const p = (O = (w = f[e]) == null ? void 0 : w.queries) == null ? void 0 : O[m.queryCacheKey], b = (T = f[e]) == null ? void 0 : T.config.refetchOnMountOrArgChange, R = p == null ? void 0 : p.fulfilledTimeStamp, C = m.forceRefetch ?? (m.subscribe && b);
    return C ? C === !0 || (Number(/* @__PURE__ */ new Date()) - Number(R)) / 1e3 >= C : !1;
  }
  const h = et(`${e}/executeQuery`, y, {
    getPendingMeta() {
      return {
        startedTimeStamp: Date.now(),
        [_e]: !0
      };
    },
    condition(m, {
      getState: f
    }) {
      var T, E, P;
      const p = f(), b = (E = (T = p[e]) == null ? void 0 : T.queries) == null ? void 0 : E[m.queryCacheKey], R = b == null ? void 0 : b.fulfilledTimeStamp, C = m.originalArgs, w = b == null ? void 0 : b.originalArgs, O = r[m.endpointName];
      return Mt(m) ? !0 : (b == null ? void 0 : b.status) === "pending" ? !1 : l(m, p) || Jr(O) && ((P = O == null ? void 0 : O.forceRefetch) != null && P.call(O, {
        currentArg: C,
        previousArg: w,
        endpointState: b,
        state: p
      })) ? !0 : !R;
    },
    dispatchConditionRejection: !0
  }), a = et(`${e}/executeMutation`, y, {
    getPendingMeta() {
      return {
        startedTimeStamp: Date.now(),
        [_e]: !0
      };
    }
  }), d = (m) => "force" in m, g = (m) => "ifOlderThan" in m, v = (m, f, p) => (b, R) => {
    const C = d(p) && p.force, w = g(p) && p.ifOlderThan, O = (E = !0) => {
      const P = {
        forceRefetch: E,
        isPrefetch: !0
      };
      return i.endpoints[m].initiate(f, P);
    }, T = i.endpoints[m].select(f)(R());
    if (C)
      b(O());
    else if (w) {
      const E = T == null ? void 0 : T.fulfilledTimeStamp;
      if (!E) {
        b(O());
        return;
      }
      (Number(/* @__PURE__ */ new Date()) - Number(new Date(E))) / 1e3 >= w && b(O());
    } else
      b(O(!1));
  };
  function _(m) {
    return (f) => {
      var p, b;
      return ((b = (p = f == null ? void 0 : f.meta) == null ? void 0 : p.arg) == null ? void 0 : b.endpointName) === m;
    };
  }
  function S(m, f) {
    return {
      matchPending: be(qt(m), _(f)),
      matchFulfilled: be(re(m), _(f)),
      matchRejected: be(pe(m), _(f))
    };
  }
  return {
    queryThunk: h,
    mutationThunk: a,
    prefetch: v,
    updateQueryData: c,
    upsertQueryData: o,
    patchQueryData: u,
    buildMatchThunkActions: S
  };
}
function Yr(e, t, r, n) {
  return Lt(r[e.meta.arg.endpointName][t], re(e) ? e.payload : void 0, ot(e) ? e.payload : void 0, e.meta.arg.originalArgs, "baseQueryMeta" in e.meta ? e.meta.baseQueryMeta : void 0, n);
}
function Qe(e, t, r) {
  const n = e[t];
  n && r(n);
}
function Ae(e) {
  return ("arg" in e ? e.arg.fixedCacheKey : e.fixedCacheKey) ?? e.requestId;
}
function mr(e, t, r) {
  const n = e[Ae(t)];
  n && r(n);
}
var me = {};
function ro({
  reducerPath: e,
  queryThunk: t,
  mutationThunk: r,
  context: {
    endpointDefinitions: n,
    apiUid: i,
    extractRehydrationInfo: s,
    hasRehydrationInfo: u
  },
  assertTagType: c,
  config: o
}) {
  const y = A(`${e}/resetApiState`), l = ie({
    name: `${e}/queries`,
    initialState: me,
    reducers: {
      removeQueryResult: {
        reducer(f, {
          payload: {
            queryCacheKey: p
          }
        }) {
          delete f[p];
        },
        prepare: ge()
      },
      queryResultPatched: {
        reducer(f, {
          payload: {
            queryCacheKey: p,
            patches: b
          }
        }) {
          Qe(f, p, (R) => {
            R.data = er(R.data, b.concat());
          });
        },
        prepare: ge()
      }
    },
    extraReducers(f) {
      f.addCase(t.pending, (p, {
        meta: b,
        meta: {
          arg: R
        }
      }) => {
        var w;
        const C = Mt(R);
        p[w = R.queryCacheKey] ?? (p[w] = {
          status: "uninitialized",
          endpointName: R.endpointName
        }), Qe(p, R.queryCacheKey, (O) => {
          O.status = "pending", O.requestId = C && O.requestId ? (
            // for `upsertQuery` **updates**, keep the current `requestId`
            O.requestId
          ) : (
            // for normal queries or `upsertQuery` **inserts** always update the `requestId`
            b.requestId
          ), R.originalArgs !== void 0 && (O.originalArgs = R.originalArgs), O.startedTimeStamp = b.startedTimeStamp;
        });
      }).addCase(t.fulfilled, (p, {
        meta: b,
        payload: R
      }) => {
        Qe(p, b.arg.queryCacheKey, (C) => {
          if (C.requestId !== b.requestId && !Mt(b.arg)) return;
          const {
            merge: w
          } = n[b.arg.endpointName];
          if (C.status = "fulfilled", w)
            if (C.data !== void 0) {
              const {
                fulfilledTimeStamp: O,
                arg: T,
                baseQueryMeta: E,
                requestId: P
              } = b;
              let M = ke(C.data, (k) => w(k, R, {
                arg: T.originalArgs,
                baseQueryMeta: E,
                fulfilledTimeStamp: O,
                requestId: P
              }));
              C.data = M;
            } else
              C.data = R;
          else
            C.data = n[b.arg.endpointName].structuralSharing ?? !0 ? Hr(Z(C.data) ? Mn(C.data) : C.data, R) : R;
          delete C.error, C.fulfilledTimeStamp = b.fulfilledTimeStamp;
        });
      }).addCase(t.rejected, (p, {
        meta: {
          condition: b,
          arg: R,
          requestId: C
        },
        error: w,
        payload: O
      }) => {
        Qe(p, R.queryCacheKey, (T) => {
          if (!b) {
            if (T.requestId !== C) return;
            T.status = "rejected", T.error = O ?? w;
          }
        });
      }).addMatcher(u, (p, b) => {
        const {
          queries: R
        } = s(b);
        for (const [C, w] of Object.entries(R))
          // do not rehydrate entries that were currently in flight.
          ((w == null ? void 0 : w.status) === "fulfilled" || (w == null ? void 0 : w.status) === "rejected") && (p[C] = w);
      });
    }
  }), h = ie({
    name: `${e}/mutations`,
    initialState: me,
    reducers: {
      removeMutationResult: {
        reducer(f, {
          payload: p
        }) {
          const b = Ae(p);
          b in f && delete f[b];
        },
        prepare: ge()
      }
    },
    extraReducers(f) {
      f.addCase(r.pending, (p, {
        meta: b,
        meta: {
          requestId: R,
          arg: C,
          startedTimeStamp: w
        }
      }) => {
        C.track && (p[Ae(b)] = {
          requestId: R,
          status: "pending",
          endpointName: C.endpointName,
          startedTimeStamp: w
        });
      }).addCase(r.fulfilled, (p, {
        payload: b,
        meta: R
      }) => {
        R.arg.track && mr(p, R, (C) => {
          C.requestId === R.requestId && (C.status = "fulfilled", C.data = b, C.fulfilledTimeStamp = R.fulfilledTimeStamp);
        });
      }).addCase(r.rejected, (p, {
        payload: b,
        error: R,
        meta: C
      }) => {
        C.arg.track && mr(p, C, (w) => {
          w.requestId === C.requestId && (w.status = "rejected", w.error = b ?? R);
        });
      }).addMatcher(u, (p, b) => {
        const {
          mutations: R
        } = s(b);
        for (const [C, w] of Object.entries(R))
          // do not rehydrate entries that were currently in flight.
          ((w == null ? void 0 : w.status) === "fulfilled" || (w == null ? void 0 : w.status) === "rejected") && // only rehydrate endpoints that were persisted using a `fixedCacheKey`
          C !== (w == null ? void 0 : w.requestId) && (p[C] = w);
      });
    }
  }), a = ie({
    name: `${e}/invalidation`,
    initialState: me,
    reducers: {
      updateProvidedBy: {
        reducer(f, p) {
          var C, w;
          const {
            queryCacheKey: b,
            providedTags: R
          } = p.payload;
          for (const O of Object.values(f))
            for (const T of Object.values(O)) {
              const E = T.indexOf(b);
              E !== -1 && T.splice(E, 1);
            }
          for (const {
            type: O,
            id: T
          } of R) {
            const E = (C = f[O] ?? (f[O] = {}))[w = T || "__internal_without_id"] ?? (C[w] = []);
            E.includes(b) || E.push(b);
          }
        },
        prepare: ge()
      }
    },
    extraReducers(f) {
      f.addCase(l.actions.removeQueryResult, (p, {
        payload: {
          queryCacheKey: b
        }
      }) => {
        for (const R of Object.values(p))
          for (const C of Object.values(R)) {
            const w = C.indexOf(b);
            w !== -1 && C.splice(w, 1);
          }
      }).addMatcher(u, (p, b) => {
        var C, w;
        const {
          provided: R
        } = s(b);
        for (const [O, T] of Object.entries(R))
          for (const [E, P] of Object.entries(T)) {
            const M = (C = p[O] ?? (p[O] = {}))[w = E || "__internal_without_id"] ?? (C[w] = []);
            for (const k of P)
              M.includes(k) || M.push(k);
          }
      }).addMatcher(j(re(t), ot(t)), (p, b) => {
        const R = Yr(b, "providesTags", n, c), {
          queryCacheKey: C
        } = b.meta.arg;
        a.caseReducers.updateProvidedBy(p, a.actions.updateProvidedBy({
          queryCacheKey: C,
          providedTags: R
        }));
      });
    }
  }), d = ie({
    name: `${e}/subscriptions`,
    initialState: me,
    reducers: {
      updateSubscriptionOptions(f, p) {
      },
      unsubscribeQueryResult(f, p) {
      },
      internal_getRTKQSubscriptions() {
      }
    }
  }), g = ie({
    name: `${e}/internalSubscriptions`,
    initialState: me,
    reducers: {
      subscriptionsUpdated: {
        reducer(f, p) {
          return er(f, p.payload);
        },
        prepare: ge()
      }
    }
  }), v = ie({
    name: `${e}/config`,
    initialState: {
      online: Bi(),
      focused: Wi(),
      middlewareRegistered: !1,
      ...o
    },
    reducers: {
      middlewareRegistered(f, {
        payload: p
      }) {
        f.middlewareRegistered = f.middlewareRegistered === "conflict" || i !== p ? "conflict" : !0;
      }
    },
    extraReducers: (f) => {
      f.addCase(Ut, (p) => {
        p.online = !0;
      }).addCase(Gr, (p) => {
        p.online = !1;
      }).addCase(Nt, (p) => {
        p.focused = !0;
      }).addCase(Vr, (p) => {
        p.focused = !1;
      }).addMatcher(u, (p) => ({
        ...p
      }));
    }
  }), _ = An({
    queries: l.reducer,
    mutations: h.reducer,
    provided: a.reducer,
    subscriptions: g.reducer,
    config: v.reducer
  }), S = (f, p) => _(y.match(p) ? void 0 : f, p), m = {
    ...v.actions,
    ...l.actions,
    ...d.actions,
    ...g.actions,
    ...h.actions,
    ...a.actions,
    resetApiState: y
  };
  return {
    reducer: S,
    actions: m
  };
}
var oe = /* @__PURE__ */ Symbol.for("RTKQ/skipToken"), Xr = {
  status: "uninitialized"
  /* uninitialized */
}, _r = /* @__PURE__ */ ke(Xr, () => {
}), vr = /* @__PURE__ */ ke(Xr, () => {
});
function no({
  serializeQueryArgs: e,
  reducerPath: t,
  createSelector: r
}) {
  const n = (h) => _r, i = (h) => vr;
  return {
    buildQuerySelector: c,
    buildMutationSelector: o,
    selectInvalidatedBy: y,
    selectCachedArgsForQuery: l
  };
  function s(h) {
    return {
      ...h,
      ...Qi(h.status)
    };
  }
  function u(h) {
    return h[t];
  }
  function c(h, a) {
    return (d) => {
      const g = e({
        queryArgs: d,
        endpointDefinition: a,
        endpointName: h
      });
      return r(d === oe ? n : (S) => {
        var m, f;
        return ((f = (m = u(S)) == null ? void 0 : m.queries) == null ? void 0 : f[g]) ?? _r;
      }, s);
    };
  }
  function o() {
    return (h) => {
      let a;
      return typeof h == "object" ? a = Ae(h) ?? oe : a = h, r(a === oe ? i : (v) => {
        var _, S;
        return ((S = (_ = u(v)) == null ? void 0 : _.mutations) == null ? void 0 : S[a]) ?? vr;
      }, s);
    };
  }
  function y(h, a) {
    const d = h[t], g = /* @__PURE__ */ new Set();
    for (const v of a.map(Pt)) {
      const _ = d.provided[v.type];
      if (!_)
        continue;
      let S = (v.id !== void 0 ? (
        // id given: invalidate all queries that provide this type & id
        _[v.id]
      ) : (
        // no id: invalidate all queries that provide this type
        lr(Object.values(_))
      )) ?? [];
      for (const m of S)
        g.add(m);
    }
    return lr(Array.from(g.values()).map((v) => {
      const _ = d.queries[v];
      return _ ? [{
        queryCacheKey: v,
        endpointName: _.endpointName,
        originalArgs: _.originalArgs
      }] : [];
    }));
  }
  function l(h, a) {
    return Object.values(h[t].queries).filter(
      (d) => (d == null ? void 0 : d.endpointName) === a && d.status !== "uninitialized"
      /* uninitialized */
    ).map((d) => d.originalArgs);
  }
}
var fe = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0, br = ({
  endpointName: e,
  queryArgs: t
}) => {
  let r = "";
  const n = fe == null ? void 0 : fe.get(t);
  if (typeof n == "string")
    r = n;
  else {
    const i = JSON.stringify(t, (s, u) => (u = typeof u == "bigint" ? {
      $bigint: u.toString()
    } : u, u = te(u) ? Object.keys(u).sort().reduce((c, o) => (c[o] = u[o], c), {}) : u, u));
    te(t) && (fe == null || fe.set(t, i)), r = i;
  }
  return `${e}(${r})`;
};
function io(...e) {
  return function(r) {
    const n = je((y) => {
      var l;
      return (l = r.extractRehydrationInfo) == null ? void 0 : l.call(r, y, {
        reducerPath: r.reducerPath ?? "api"
      });
    }), i = {
      reducerPath: "api",
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: !1,
      refetchOnFocus: !1,
      refetchOnReconnect: !1,
      invalidationBehavior: "delayed",
      ...r,
      extractRehydrationInfo: n,
      serializeQueryArgs(y) {
        let l = br;
        if ("serializeQueryArgs" in y.endpointDefinition) {
          const h = y.endpointDefinition.serializeQueryArgs;
          l = (a) => {
            const d = h(a);
            return typeof d == "string" ? d : br({
              ...a,
              queryArgs: d
            });
          };
        } else r.serializeQueryArgs && (l = r.serializeQueryArgs);
        return l(y);
      },
      tagTypes: [...r.tagTypes || []]
    }, s = {
      endpointDefinitions: {},
      batch(y) {
        y();
      },
      apiUid: Kr(),
      extractRehydrationInfo: n,
      hasRehydrationInfo: je((y) => n(y) != null)
    }, u = {
      injectEndpoints: o,
      enhanceEndpoints({
        addTagTypes: y,
        endpoints: l
      }) {
        if (y)
          for (const h of y)
            i.tagTypes.includes(h) || i.tagTypes.push(h);
        if (l)
          for (const [h, a] of Object.entries(l))
            typeof a == "function" ? a(s.endpointDefinitions[h]) : Object.assign(s.endpointDefinitions[h] || {}, a);
        return u;
      }
    }, c = e.map((y) => y.init(u, i, s));
    function o(y) {
      const l = y.endpoints({
        query: (h) => ({
          ...h,
          type: "query"
          /* query */
        }),
        mutation: (h) => ({
          ...h,
          type: "mutation"
          /* mutation */
        })
      });
      for (const [h, a] of Object.entries(l)) {
        if (y.overrideExisting !== !0 && h in s.endpointDefinitions) {
          if (y.overrideExisting === "throw")
            throw new Error(V(39));
          typeof process < "u";
          continue;
        }
        s.endpointDefinitions[h] = a;
        for (const d of c)
          d.injectEndpoint(h, a);
      }
      return u;
    }
    return u.injectEndpoints({
      endpoints: r.endpoints
    });
  };
}
function ee(e, ...t) {
  return Object.assign(e, ...t);
}
var oo = ({
  api: e,
  queryThunk: t,
  internalState: r
}) => {
  const n = `${e.reducerPath}/subscriptions`;
  let i = null, s = null;
  const {
    updateSubscriptionOptions: u,
    unsubscribeQueryResult: c
  } = e.internalActions, o = (d, g) => {
    var _, S, m;
    if (u.match(g)) {
      const {
        queryCacheKey: f,
        requestId: p,
        options: b
      } = g.payload;
      return (_ = d == null ? void 0 : d[f]) != null && _[p] && (d[f][p] = b), !0;
    }
    if (c.match(g)) {
      const {
        queryCacheKey: f,
        requestId: p
      } = g.payload;
      return d[f] && delete d[f][p], !0;
    }
    if (e.internalActions.removeQueryResult.match(g))
      return delete d[g.payload.queryCacheKey], !0;
    if (t.pending.match(g)) {
      const {
        meta: {
          arg: f,
          requestId: p
        }
      } = g, b = d[S = f.queryCacheKey] ?? (d[S] = {});
      return b[`${p}_running`] = {}, f.subscribe && (b[p] = f.subscriptionOptions ?? b[p] ?? {}), !0;
    }
    let v = !1;
    if (t.fulfilled.match(g) || t.rejected.match(g)) {
      const f = d[g.meta.arg.queryCacheKey] || {}, p = `${g.meta.requestId}_running`;
      v || (v = !!f[p]), delete f[p];
    }
    if (t.rejected.match(g)) {
      const {
        meta: {
          condition: f,
          arg: p,
          requestId: b
        }
      } = g;
      if (f && p.subscribe) {
        const R = d[m = p.queryCacheKey] ?? (d[m] = {});
        R[b] = p.subscriptionOptions ?? R[b] ?? {}, v = !0;
      }
    }
    return v;
  }, y = () => r.currentSubscriptions, a = {
    getSubscriptions: y,
    getSubscriptionCount: (d) => {
      const v = y()[d] ?? {};
      return de(v);
    },
    isRequestSubscribed: (d, g) => {
      var _;
      const v = y();
      return !!((_ = v == null ? void 0 : v[d]) != null && _[g]);
    }
  };
  return (d, g) => {
    if (i || (i = JSON.parse(JSON.stringify(r.currentSubscriptions))), e.util.resetApiState.match(d))
      return i = r.currentSubscriptions = {}, s = null, [!0, !1];
    if (e.internalActions.internal_getRTKQSubscriptions.match(d))
      return [!1, a];
    const v = o(r.currentSubscriptions, d);
    let _ = !0;
    if (v) {
      s || (s = setTimeout(() => {
        const f = JSON.parse(JSON.stringify(r.currentSubscriptions)), [, p] = Lr(i, () => f);
        g.next(e.internalActions.subscriptionsUpdated(p)), i = f, s = null;
      }, 500));
      const S = typeof d.type == "string" && !!d.type.startsWith(n), m = t.rejected.match(d) && d.meta.condition && !!d.meta.arg.subscribe;
      _ = !S && !m;
    }
    return [_, !1];
  };
};
function so(e) {
  for (const t in e)
    return !1;
  return !0;
}
var ao = 2147483647 / 1e3 - 1, uo = ({
  reducerPath: e,
  api: t,
  queryThunk: r,
  context: n,
  internalState: i
}) => {
  const {
    removeQueryResult: s,
    unsubscribeQueryResult: u
  } = t.internalActions, c = j(u.match, r.fulfilled, r.rejected);
  function o(a) {
    const d = i.currentSubscriptions[a];
    return !!d && !so(d);
  }
  const y = {}, l = (a, d, g) => {
    var v;
    if (c(a)) {
      const _ = d.getState()[e], {
        queryCacheKey: S
      } = u.match(a) ? a.payload : a.meta.arg;
      h(S, (v = _.queries[S]) == null ? void 0 : v.endpointName, d, _.config);
    }
    if (t.util.resetApiState.match(a))
      for (const [_, S] of Object.entries(y))
        S && clearTimeout(S), delete y[_];
    if (n.hasRehydrationInfo(a)) {
      const _ = d.getState()[e], {
        queries: S
      } = n.extractRehydrationInfo(a);
      for (const [m, f] of Object.entries(S))
        h(m, f == null ? void 0 : f.endpointName, d, _.config);
    }
  };
  function h(a, d, g, v) {
    const _ = n.endpointDefinitions[d], S = (_ == null ? void 0 : _.keepUnusedDataFor) ?? v.keepUnusedDataFor;
    if (S === 1 / 0)
      return;
    const m = Math.max(0, Math.min(S, ao));
    if (!o(a)) {
      const f = y[a];
      f && clearTimeout(f), y[a] = setTimeout(() => {
        o(a) || g.dispatch(s({
          queryCacheKey: a
        })), delete y[a];
      }, m * 1e3);
    }
  }
  return l;
}, Sr = new Error("Promise never resolved before cacheEntryRemoved."), co = ({
  api: e,
  reducerPath: t,
  context: r,
  queryThunk: n,
  mutationThunk: i,
  internalState: s
}) => {
  const u = Et(n), c = Et(i), o = re(n, i), y = {}, l = (d, g, v) => {
    const _ = h(d);
    if (n.pending.match(d)) {
      const S = v[t].queries[_], m = g.getState()[t].queries[_];
      !S && m && a(d.meta.arg.endpointName, d.meta.arg.originalArgs, _, g, d.meta.requestId);
    } else if (i.pending.match(d))
      g.getState()[t].mutations[_] && a(d.meta.arg.endpointName, d.meta.arg.originalArgs, _, g, d.meta.requestId);
    else if (o(d)) {
      const S = y[_];
      S != null && S.valueResolved && (S.valueResolved({
        data: d.payload,
        meta: d.meta.baseQueryMeta
      }), delete S.valueResolved);
    } else if (e.internalActions.removeQueryResult.match(d) || e.internalActions.removeMutationResult.match(d)) {
      const S = y[_];
      S && (delete y[_], S.cacheEntryRemoved());
    } else if (e.util.resetApiState.match(d))
      for (const [S, m] of Object.entries(y))
        delete y[S], m.cacheEntryRemoved();
  };
  function h(d) {
    return u(d) ? d.meta.arg.queryCacheKey : c(d) ? d.meta.arg.fixedCacheKey ?? d.meta.requestId : e.internalActions.removeQueryResult.match(d) ? d.payload.queryCacheKey : e.internalActions.removeMutationResult.match(d) ? Ae(d.payload) : "";
  }
  function a(d, g, v, _, S) {
    const m = r.endpointDefinitions[d], f = m == null ? void 0 : m.onCacheEntryAdded;
    if (!f) return;
    const p = {}, b = new Promise((E) => {
      p.cacheEntryRemoved = E;
    }), R = Promise.race([new Promise((E) => {
      p.valueResolved = E;
    }), b.then(() => {
      throw Sr;
    })]);
    R.catch(() => {
    }), y[v] = p;
    const C = e.endpoints[d].select(m.type === "query" ? g : v), w = _.dispatch((E, P, M) => M), O = {
      ..._,
      getCacheEntry: () => C(_.getState()),
      requestId: S,
      extra: w,
      updateCachedData: m.type === "query" ? (E) => _.dispatch(e.util.updateQueryData(d, g, E)) : void 0,
      cacheDataLoaded: R,
      cacheEntryRemoved: b
    }, T = f(g, O);
    Promise.resolve(T).catch((E) => {
      if (E !== Sr)
        throw E;
    });
  }
  return l;
}, fo = ({
  api: e,
  context: {
    apiUid: t
  },
  reducerPath: r
}) => (n, i) => {
  e.util.resetApiState.match(n) && i.dispatch(e.internalActions.middlewareRegistered(t)), typeof process < "u";
}, lo = ({
  reducerPath: e,
  context: t,
  context: {
    endpointDefinitions: r
  },
  mutationThunk: n,
  queryThunk: i,
  api: s,
  assertTagType: u,
  refetchQuery: c,
  internalState: o
}) => {
  const {
    removeQueryResult: y
  } = s.internalActions, l = j(re(n), ot(n)), h = j(re(n, i), pe(n, i));
  let a = [];
  const d = (_, S) => {
    l(_) ? v(Yr(_, "invalidatesTags", r, u), S) : h(_) ? v([], S) : s.util.invalidateTags.match(_) && v(Lt(_.payload, void 0, void 0, void 0, void 0, u), S);
  };
  function g(_) {
    var S, m;
    for (const f in _.queries)
      if (((S = _.queries[f]) == null ? void 0 : S.status) === "pending") return !0;
    for (const f in _.mutations)
      if (((m = _.mutations[f]) == null ? void 0 : m.status) === "pending") return !0;
    return !1;
  }
  function v(_, S) {
    const m = S.getState(), f = m[e];
    if (a.push(..._), f.config.invalidationBehavior === "delayed" && g(f))
      return;
    const p = a;
    if (a = [], p.length === 0) return;
    const b = s.util.selectInvalidatedBy(m, p);
    t.batch(() => {
      const R = Array.from(b.values());
      for (const {
        queryCacheKey: C
      } of R) {
        const w = f.queries[C], O = o.currentSubscriptions[C] ?? {};
        w && (de(O) === 0 ? S.dispatch(y({
          queryCacheKey: C
        })) : w.status !== "uninitialized" && S.dispatch(c(w, C)));
      }
    });
  }
  return d;
}, po = ({
  reducerPath: e,
  queryThunk: t,
  api: r,
  refetchQuery: n,
  internalState: i
}) => {
  const s = {}, u = (a, d) => {
    (r.internalActions.updateSubscriptionOptions.match(a) || r.internalActions.unsubscribeQueryResult.match(a)) && o(a.payload, d), (t.pending.match(a) || t.rejected.match(a) && a.meta.condition) && o(a.meta.arg, d), (t.fulfilled.match(a) || t.rejected.match(a) && !a.meta.condition) && c(a.meta.arg, d), r.util.resetApiState.match(a) && l();
  };
  function c({
    queryCacheKey: a
  }, d) {
    const g = d.getState()[e], v = g.queries[a], _ = i.currentSubscriptions[a];
    if (!v || v.status === "uninitialized") return;
    const {
      lowestPollingInterval: S,
      skipPollingIfUnfocused: m
    } = h(_);
    if (!Number.isFinite(S)) return;
    const f = s[a];
    f != null && f.timeout && (clearTimeout(f.timeout), f.timeout = void 0);
    const p = Date.now() + S;
    s[a] = {
      nextPollTimestamp: p,
      pollingInterval: S,
      timeout: setTimeout(() => {
        (g.config.focused || !m) && d.dispatch(n(v, a)), c({
          queryCacheKey: a
        }, d);
      }, S)
    };
  }
  function o({
    queryCacheKey: a
  }, d) {
    const v = d.getState()[e].queries[a], _ = i.currentSubscriptions[a];
    if (!v || v.status === "uninitialized")
      return;
    const {
      lowestPollingInterval: S
    } = h(_);
    if (!Number.isFinite(S)) {
      y(a);
      return;
    }
    const m = s[a], f = Date.now() + S;
    (!m || f < m.nextPollTimestamp) && c({
      queryCacheKey: a
    }, d);
  }
  function y(a) {
    const d = s[a];
    d != null && d.timeout && clearTimeout(d.timeout), delete s[a];
  }
  function l() {
    for (const a of Object.keys(s))
      y(a);
  }
  function h(a = {}) {
    let d = !1, g = Number.POSITIVE_INFINITY;
    for (let v in a)
      a[v].pollingInterval && (g = Math.min(a[v].pollingInterval, g), d = a[v].skipPollingIfUnfocused || d);
    return {
      lowestPollingInterval: g,
      skipPollingIfUnfocused: d
    };
  }
  return u;
}, yo = ({
  api: e,
  context: t,
  queryThunk: r,
  mutationThunk: n
}) => {
  const i = qt(r, n), s = pe(r, n), u = re(r, n), c = {};
  return (y, l) => {
    var h, a;
    if (i(y)) {
      const {
        requestId: d,
        arg: {
          endpointName: g,
          originalArgs: v
        }
      } = y.meta, _ = t.endpointDefinitions[g], S = _ == null ? void 0 : _.onQueryStarted;
      if (S) {
        const m = {}, f = new Promise((C, w) => {
          m.resolve = C, m.reject = w;
        });
        f.catch(() => {
        }), c[d] = m;
        const p = e.endpoints[g].select(_.type === "query" ? v : d), b = l.dispatch((C, w, O) => O), R = {
          ...l,
          getCacheEntry: () => p(l.getState()),
          requestId: d,
          extra: b,
          updateCachedData: _.type === "query" ? (C) => l.dispatch(e.util.updateQueryData(g, v, C)) : void 0,
          queryFulfilled: f
        };
        S(v, R);
      }
    } else if (u(y)) {
      const {
        requestId: d,
        baseQueryMeta: g
      } = y.meta;
      (h = c[d]) == null || h.resolve({
        data: y.payload,
        meta: g
      }), delete c[d];
    } else if (s(y)) {
      const {
        requestId: d,
        rejectedWithValue: g,
        baseQueryMeta: v
      } = y.meta;
      (a = c[d]) == null || a.reject({
        error: y.payload ?? y.error,
        isUnhandledError: !g,
        meta: v
      }), delete c[d];
    }
  };
}, ho = ({
  reducerPath: e,
  context: t,
  api: r,
  refetchQuery: n,
  internalState: i
}) => {
  const {
    removeQueryResult: s
  } = r.internalActions, u = (o, y) => {
    Nt.match(o) && c(y, "refetchOnFocus"), Ut.match(o) && c(y, "refetchOnReconnect");
  };
  function c(o, y) {
    const l = o.getState()[e], h = l.queries, a = i.currentSubscriptions;
    t.batch(() => {
      for (const d of Object.keys(a)) {
        const g = h[d], v = a[d];
        if (!v || !g) continue;
        (Object.values(v).some((S) => S[y] === !0) || Object.values(v).every((S) => S[y] === void 0) && l.config[y]) && (de(v) === 0 ? o.dispatch(s({
          queryCacheKey: d
        })) : g.status !== "uninitialized" && o.dispatch(n(g, d)));
      }
    });
  }
  return u;
};
function go(e) {
  const {
    reducerPath: t,
    queryThunk: r,
    api: n,
    context: i
  } = e, {
    apiUid: s
  } = i, u = {
    invalidateTags: A(`${t}/invalidateTags`)
  }, c = (h) => h.type.startsWith(`${t}/`), o = [fo, uo, lo, po, co, yo];
  return {
    middleware: (h) => {
      let a = !1;
      const g = {
        ...e,
        internalState: {
          currentSubscriptions: {}
        },
        refetchQuery: l,
        isThisApiSliceAction: c
      }, v = o.map((m) => m(g)), _ = oo(g), S = ho(g);
      return (m) => (f) => {
        if (!Dr(f))
          return m(f);
        a || (a = !0, h.dispatch(n.internalActions.middlewareRegistered(s)));
        const p = {
          ...h,
          next: m
        }, b = h.getState(), [R, C] = _(f, p, b);
        let w;
        if (R ? w = m(f) : w = C, h.getState()[t] && (S(f, p, b), c(f) || i.hasRehydrationInfo(f)))
          for (const O of v)
            O(f, p, b);
        return w;
      };
    },
    actions: u
  };
  function l(h, a, d = {}) {
    return r({
      type: "query",
      endpointName: h.endpointName,
      originalArgs: h.originalArgs,
      subscribe: !1,
      forceRefetch: !0,
      queryCacheKey: a,
      ...d
    });
  }
}
var Cr = /* @__PURE__ */ Symbol(), mo = ({
  createSelector: e = ye
} = {}) => ({
  name: Cr,
  init(t, {
    baseQuery: r,
    tagTypes: n,
    reducerPath: i,
    serializeQueryArgs: s,
    keepUnusedDataFor: u,
    refetchOnMountOrArgChange: c,
    refetchOnFocus: o,
    refetchOnReconnect: y,
    invalidationBehavior: l
  }, h) {
    Ln();
    const a = (q) => (typeof process < "u", q);
    Object.assign(t, {
      reducerPath: i,
      endpoints: {},
      internalActions: {
        onOnline: Ut,
        onOffline: Gr,
        onFocus: Nt,
        onFocusLost: Vr
      },
      util: {}
    });
    const {
      queryThunk: d,
      mutationThunk: g,
      patchQueryData: v,
      updateQueryData: _,
      upsertQueryData: S,
      prefetch: m,
      buildMatchThunkActions: f
    } = to({
      baseQuery: r,
      reducerPath: i,
      context: h,
      api: t,
      serializeQueryArgs: s,
      assertTagType: a
    }), {
      reducer: p,
      actions: b
    } = ro({
      context: h,
      queryThunk: d,
      mutationThunk: g,
      reducerPath: i,
      assertTagType: a,
      config: {
        refetchOnFocus: o,
        refetchOnReconnect: y,
        refetchOnMountOrArgChange: c,
        keepUnusedDataFor: u,
        reducerPath: i,
        invalidationBehavior: l
      }
    });
    ee(t.util, {
      patchQueryData: v,
      updateQueryData: _,
      upsertQueryData: S,
      prefetch: m,
      resetApiState: b.resetApiState
    }), ee(t.internalActions, b);
    const {
      middleware: R,
      actions: C
    } = go({
      reducerPath: i,
      context: h,
      queryThunk: d,
      mutationThunk: g,
      api: t,
      assertTagType: a
    });
    ee(t.util, C), ee(t, {
      reducer: p,
      middleware: R
    });
    const {
      buildQuerySelector: w,
      buildMutationSelector: O,
      selectInvalidatedBy: T,
      selectCachedArgsForQuery: E
    } = no({
      serializeQueryArgs: s,
      reducerPath: i,
      createSelector: e
    });
    ee(t.util, {
      selectInvalidatedBy: T,
      selectCachedArgsForQuery: E
    });
    const {
      buildInitiateQuery: P,
      buildInitiateMutation: M,
      getRunningMutationThunk: k,
      getRunningMutationsThunk: $,
      getRunningQueriesThunk: x,
      getRunningQueryThunk: Q
    } = eo({
      queryThunk: d,
      mutationThunk: g,
      api: t,
      serializeQueryArgs: s,
      context: h
    });
    return ee(t.util, {
      getRunningMutationThunk: k,
      getRunningMutationsThunk: $,
      getRunningQueryThunk: Q,
      getRunningQueriesThunk: x
    }), {
      name: Cr,
      injectEndpoint(q, L) {
        var K;
        const D = t;
        (K = D.endpoints)[q] ?? (K[q] = {}), Jr(L) ? ee(D.endpoints[q], {
          name: q,
          select: w(q, L),
          initiate: P(q, L)
        }, f(d, q)) : Xi(L) && ee(D.endpoints[q], {
          name: q,
          select: O(),
          initiate: M(q)
        }, f(g, q));
      }
    };
  }
});
function Zr(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var jr = { exports: {} }, I = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var De = Symbol.for("react.element"), _o = Symbol.for("react.portal"), vo = Symbol.for("react.fragment"), bo = Symbol.for("react.strict_mode"), So = Symbol.for("react.profiler"), Co = Symbol.for("react.provider"), Ro = Symbol.for("react.context"), wo = Symbol.for("react.forward_ref"), Oo = Symbol.for("react.suspense"), To = Symbol.for("react.memo"), Eo = Symbol.for("react.lazy"), Rr = Symbol.iterator;
function Ao(e) {
  return e === null || typeof e != "object" ? null : (e = Rr && e[Rr] || e["@@iterator"], typeof e == "function" ? e : null);
}
var en = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, tn = Object.assign, rn = {};
function he(e, t, r) {
  this.props = e, this.context = t, this.refs = rn, this.updater = r || en;
}
he.prototype.isReactComponent = {};
he.prototype.setState = function(e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e, t, "setState");
};
he.prototype.forceUpdate = function(e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function nn() {
}
nn.prototype = he.prototype;
function zt(e, t, r) {
  this.props = e, this.context = t, this.refs = rn, this.updater = r || en;
}
var Qt = zt.prototype = new nn();
Qt.constructor = zt;
tn(Qt, he.prototype);
Qt.isPureReactComponent = !0;
var wr = Array.isArray, on = Object.prototype.hasOwnProperty, Kt = { current: null }, sn = { key: !0, ref: !0, __self: !0, __source: !0 };
function an(e, t, r) {
  var n, i = {}, s = null, u = null;
  if (t != null) for (n in t.ref !== void 0 && (u = t.ref), t.key !== void 0 && (s = "" + t.key), t) on.call(t, n) && !sn.hasOwnProperty(n) && (i[n] = t[n]);
  var c = arguments.length - 2;
  if (c === 1) i.children = r;
  else if (1 < c) {
    for (var o = Array(c), y = 0; y < c; y++) o[y] = arguments[y + 2];
    i.children = o;
  }
  if (e && e.defaultProps) for (n in c = e.defaultProps, c) i[n] === void 0 && (i[n] = c[n]);
  return { $$typeof: De, type: e, key: s, ref: u, props: i, _owner: Kt.current };
}
function Po(e, t) {
  return { $$typeof: De, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner };
}
function Wt(e) {
  return typeof e == "object" && e !== null && e.$$typeof === De;
}
function Mo(e) {
  var t = { "=": "=0", ":": "=2" };
  return "$" + e.replace(/[=:]/g, function(r) {
    return t[r];
  });
}
var Or = /\/+/g;
function yt(e, t) {
  return typeof e == "object" && e !== null && e.key != null ? Mo("" + e.key) : t.toString(36);
}
function Ge(e, t, r, n, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var u = !1;
  if (e === null) u = !0;
  else switch (s) {
    case "string":
    case "number":
      u = !0;
      break;
    case "object":
      switch (e.$$typeof) {
        case De:
        case _o:
          u = !0;
      }
  }
  if (u) return u = e, i = i(u), e = n === "" ? "." + yt(u, 0) : n, wr(i) ? (r = "", e != null && (r = e.replace(Or, "$&/") + "/"), Ge(i, t, r, "", function(y) {
    return y;
  })) : i != null && (Wt(i) && (i = Po(i, r + (!i.key || u && u.key === i.key ? "" : ("" + i.key).replace(Or, "$&/") + "/") + e)), t.push(i)), 1;
  if (u = 0, n = n === "" ? "." : n + ":", wr(e)) for (var c = 0; c < e.length; c++) {
    s = e[c];
    var o = n + yt(s, c);
    u += Ge(s, t, r, o, i);
  }
  else if (o = Ao(e), typeof o == "function") for (e = o.call(e), c = 0; !(s = e.next()).done; ) s = s.value, o = n + yt(s, c++), u += Ge(s, t, r, o, i);
  else if (s === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
  return u;
}
function Ke(e, t, r) {
  if (e == null) return e;
  var n = [], i = 0;
  return Ge(e, n, "", "", function(s) {
    return t.call(r, s, i++);
  }), n;
}
function ko(e) {
  if (e._status === -1) {
    var t = e._result;
    t = t(), t.then(function(r) {
      (e._status === 0 || e._status === -1) && (e._status = 1, e._result = r);
    }, function(r) {
      (e._status === 0 || e._status === -1) && (e._status = 2, e._result = r);
    }), e._status === -1 && (e._status = 0, e._result = t);
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var W = { current: null }, Je = { transition: null }, Fo = { ReactCurrentDispatcher: W, ReactCurrentBatchConfig: Je, ReactCurrentOwner: Kt };
I.Children = { map: Ke, forEach: function(e, t, r) {
  Ke(e, function() {
    t.apply(this, arguments);
  }, r);
}, count: function(e) {
  var t = 0;
  return Ke(e, function() {
    t++;
  }), t;
}, toArray: function(e) {
  return Ke(e, function(t) {
    return t;
  }) || [];
}, only: function(e) {
  if (!Wt(e)) throw Error("React.Children.only expected to receive a single React element child.");
  return e;
} };
I.Component = he;
I.Fragment = vo;
I.Profiler = So;
I.PureComponent = zt;
I.StrictMode = bo;
I.Suspense = Oo;
I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Fo;
I.cloneElement = function(e, t, r) {
  if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
  var n = tn({}, e.props), i = e.key, s = e.ref, u = e._owner;
  if (t != null) {
    if (t.ref !== void 0 && (s = t.ref, u = Kt.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var c = e.type.defaultProps;
    for (o in t) on.call(t, o) && !sn.hasOwnProperty(o) && (n[o] = t[o] === void 0 && c !== void 0 ? c[o] : t[o]);
  }
  var o = arguments.length - 2;
  if (o === 1) n.children = r;
  else if (1 < o) {
    c = Array(o);
    for (var y = 0; y < o; y++) c[y] = arguments[y + 2];
    n.children = c;
  }
  return { $$typeof: De, type: e.type, key: i, ref: s, props: n, _owner: u };
};
I.createContext = function(e) {
  return e = { $$typeof: Ro, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: Co, _context: e }, e.Consumer = e;
};
I.createElement = an;
I.createFactory = function(e) {
  var t = an.bind(null, e);
  return t.type = e, t;
};
I.createRef = function() {
  return { current: null };
};
I.forwardRef = function(e) {
  return { $$typeof: wo, render: e };
};
I.isValidElement = Wt;
I.lazy = function(e) {
  return { $$typeof: Eo, _payload: { _status: -1, _result: e }, _init: ko };
};
I.memo = function(e, t) {
  return { $$typeof: To, type: e, compare: t === void 0 ? null : t };
};
I.startTransition = function(e) {
  var t = Je.transition;
  Je.transition = {};
  try {
    e();
  } finally {
    Je.transition = t;
  }
};
I.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
I.useCallback = function(e, t) {
  return W.current.useCallback(e, t);
};
I.useContext = function(e) {
  return W.current.useContext(e);
};
I.useDebugValue = function() {
};
I.useDeferredValue = function(e) {
  return W.current.useDeferredValue(e);
};
I.useEffect = function(e, t) {
  return W.current.useEffect(e, t);
};
I.useId = function() {
  return W.current.useId();
};
I.useImperativeHandle = function(e, t, r) {
  return W.current.useImperativeHandle(e, t, r);
};
I.useInsertionEffect = function(e, t) {
  return W.current.useInsertionEffect(e, t);
};
I.useLayoutEffect = function(e, t) {
  return W.current.useLayoutEffect(e, t);
};
I.useMemo = function(e, t) {
  return W.current.useMemo(e, t);
};
I.useReducer = function(e, t, r) {
  return W.current.useReducer(e, t, r);
};
I.useRef = function(e) {
  return W.current.useRef(e);
};
I.useState = function(e) {
  return W.current.useState(e);
};
I.useSyncExternalStore = function(e, t, r) {
  return W.current.useSyncExternalStore(e, t, r);
};
I.useTransition = function() {
  return W.current.useTransition();
};
I.version = "18.2.0";
jr.exports = I;
var F = jr.exports;
const un = /* @__PURE__ */ Zr(F), Tr = /* @__PURE__ */ On({
  __proto__: null,
  default: un
}, [F]);
var cn = { exports: {} }, fn = {};
/**
 * @license React
 * use-sync-external-store-with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $e = F;
function Io(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var Do = typeof Object.is == "function" ? Object.is : Io, $o = $e.useSyncExternalStore, qo = $e.useRef, xo = $e.useEffect, No = $e.useMemo, Uo = $e.useDebugValue;
fn.useSyncExternalStoreWithSelector = function(e, t, r, n, i) {
  var s = qo(null);
  if (s.current === null) {
    var u = { hasValue: !1, value: null };
    s.current = u;
  } else u = s.current;
  s = No(function() {
    function o(d) {
      if (!y) {
        if (y = !0, l = d, d = n(d), i !== void 0 && u.hasValue) {
          var g = u.value;
          if (i(g, d)) return h = g;
        }
        return h = d;
      }
      if (g = h, Do(l, d)) return g;
      var v = n(d);
      return i !== void 0 && i(g, v) ? g : (l = d, h = v);
    }
    var y = !1, l, h, a = r === void 0 ? null : r;
    return [function() {
      return o(t());
    }, a === null ? void 0 : function() {
      return o(a());
    }];
  }, [t, r, n, i]);
  var c = $o(e, s[0], s[1]);
  return xo(function() {
    u.hasValue = !0, u.value = c;
  }, [c]), Uo(c), c;
};
cn.exports = fn;
var Lo = cn.exports, X = (
  // prettier-ignore
  // @ts-ignore
  "default" in Tr ? un : Tr
), Er = Symbol.for("react-redux-context"), Ar = typeof globalThis < "u" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function zo() {
  if (!X.createContext)
    return {};
  const e = Ar[Er] ?? (Ar[Er] = /* @__PURE__ */ new Map());
  let t = e.get(X.createContext);
  return t || (t = X.createContext(
    null
  ), e.set(X.createContext, t)), t;
}
var ce = /* @__PURE__ */ zo(), Qo = () => {
  throw new Error("uSES not initialized!");
};
function Bt(e = ce) {
  return function() {
    return X.useContext(e);
  };
}
var ln = /* @__PURE__ */ Bt(), dn = Qo, Ko = (e) => {
  dn = e;
}, Wo = (e, t) => e === t;
function Bo(e = ce) {
  const t = e === ce ? ln : Bt(e), r = (n, i = {}) => {
    const { equalityFn: s = Wo, devModeChecks: u = {} } = typeof i == "function" ? { equalityFn: i } : i, {
      store: c,
      subscription: o,
      getServerState: y,
      stabilityCheck: l,
      identityFunctionCheck: h
    } = t();
    X.useRef(!0);
    const a = X.useCallback(
      {
        [n.name](g) {
          return n(g);
        }
      }[n.name],
      [n, l, u.stabilityCheck]
    ), d = dn(
      o.addNestedSub,
      c.getState,
      y || c.getState,
      a,
      s
    );
    return X.useDebugValue(d), d;
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var Ho = /* @__PURE__ */ Bo();
function Vo(e) {
  e();
}
var Go = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Jo = typeof navigator < "u" && navigator.product === "ReactNative";
Go || Jo ? X.useLayoutEffect : X.useEffect;
function Pr(e, t) {
  return e === t ? e !== 0 || t !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Se(e, t) {
  if (Pr(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  const r = Object.keys(e), n = Object.keys(t);
  if (r.length !== n.length)
    return !1;
  for (let i = 0; i < r.length; i++)
    if (!Object.prototype.hasOwnProperty.call(t, r[i]) || !Pr(e[r[i]], t[r[i]]))
      return !1;
  return !0;
}
function pn(e = ce) {
  const t = e === ce ? ln : (
    // @ts-ignore
    Bt(e)
  ), r = () => {
    const { store: n } = t();
    return n;
  };
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var yn = /* @__PURE__ */ pn();
function Yo(e = ce) {
  const t = e === ce ? yn : pn(e), r = () => t().dispatch;
  return Object.assign(r, {
    withTypes: () => r
  }), r;
}
var Xo = /* @__PURE__ */ Yo(), Zo = Vo;
Ko(Lo.useSyncExternalStoreWithSelector);
function jo(e) {
  return e.type === "query";
}
function es(e) {
  return e.type === "mutation";
}
function We(e, ...t) {
  return Object.assign(e, ...t);
}
function ht(e) {
  return e.replace(e[0], e[0].toUpperCase());
}
var le = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0, ts = ({
  endpointName: e,
  queryArgs: t
}) => {
  let r = "";
  const n = le == null ? void 0 : le.get(t);
  if (typeof n == "string")
    r = n;
  else {
    const i = JSON.stringify(t, (s, u) => (u = typeof u == "bigint" ? {
      $bigint: u.toString()
    } : u, u = te(u) ? Object.keys(u).sort().reduce((c, o) => (c[o] = u[o], c), {}) : u, u));
    te(t) && (le == null || le.set(t, i)), r = i;
  }
  return `${e}(${r})`;
}, gt = Symbol();
function Mr(e, t, r, n) {
  const i = F.useMemo(() => ({
    queryArgs: e,
    serialized: typeof e == "object" ? t({
      queryArgs: e,
      endpointDefinition: r,
      endpointName: n
    }) : e
  }), [e, t, r, n]), s = F.useRef(i);
  return F.useEffect(() => {
    s.current.serialized !== i.serialized && (s.current = i);
  }, [i]), s.current.serialized === i.serialized ? s.current.queryArgs : e;
}
function mt(e) {
  const t = F.useRef(e);
  return F.useEffect(() => {
    Se(t.current, e) || (t.current = e);
  }, [e]), Se(t.current, e) ? t.current : e;
}
var rs = () => typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", ns = /* @__PURE__ */ rs(), is = () => typeof navigator < "u" && navigator.product === "ReactNative", os = /* @__PURE__ */ is(), ss = () => ns || os ? F.useLayoutEffect : F.useEffect, as = /* @__PURE__ */ ss(), us = (e) => e.isUninitialized ? {
  ...e,
  isUninitialized: !1,
  isFetching: !0,
  isLoading: e.data === void 0,
  status: Br.pending
} : e;
function cs({
  api: e,
  moduleOptions: {
    batch: t,
    hooks: {
      useDispatch: r,
      useSelector: n,
      useStore: i
    },
    unstable__sideEffectsInRender: s,
    createSelector: u
  },
  serializeQueryArgs: c,
  context: o
}) {
  const y = s ? (g) => g() : F.useEffect;
  return {
    buildQueryHooks: a,
    buildMutationHook: d,
    usePrefetch: h
  };
  function l(g, v, _) {
    if (v != null && v.endpointName && g.isUninitialized) {
      const {
        endpointName: R
      } = v, C = o.endpointDefinitions[R];
      c({
        queryArgs: v.originalArgs,
        endpointDefinition: C,
        endpointName: R
      }) === c({
        queryArgs: _,
        endpointDefinition: C,
        endpointName: R
      }) && (v = void 0);
    }
    let S = g.isSuccess ? g.data : v == null ? void 0 : v.data;
    S === void 0 && (S = g.data);
    const m = S !== void 0, f = g.isLoading, p = (!v || v.isLoading || v.isUninitialized) && !m && f, b = g.isSuccess || f && m;
    return {
      ...g,
      data: S,
      currentData: g.data,
      isFetching: f,
      isLoading: p,
      isSuccess: b
    };
  }
  function h(g, v) {
    const _ = r(), S = mt(v);
    return F.useCallback((m, f) => _(e.util.prefetch(g, m, {
      ...S,
      ...f
    })), [g, _, S]);
  }
  function a(g) {
    const v = (m, {
      refetchOnReconnect: f,
      refetchOnFocus: p,
      refetchOnMountOrArgChange: b,
      skip: R = !1,
      pollingInterval: C = 0,
      skipPollingIfUnfocused: w = !1
    } = {}) => {
      const {
        initiate: O
      } = e.endpoints[g], T = r(), E = F.useRef(void 0);
      if (!E.current) {
        const D = T(e.internalActions.internal_getRTKQSubscriptions());
        E.current = D;
      }
      const P = Mr(
        R ? oe : m,
        // Even if the user provided a per-endpoint `serializeQueryArgs` with
        // a consistent return value, _here_ we want to use the default behavior
        // so we can tell if _anything_ actually changed. Otherwise, we can end up
        // with a case where the query args did change but the serialization doesn't,
        // and then we never try to initiate a refetch.
        ts,
        o.endpointDefinitions[g],
        g
      ), M = mt({
        refetchOnReconnect: f,
        refetchOnFocus: p,
        pollingInterval: C,
        skipPollingIfUnfocused: w
      }), k = F.useRef(!1), $ = F.useRef(void 0);
      let {
        queryCacheKey: x,
        requestId: Q
      } = $.current || {}, q = !1;
      x && Q && (q = E.current.isRequestSubscribed(x, Q));
      const L = !q && k.current;
      return y(() => {
        k.current = q;
      }), y(() => {
        L && ($.current = void 0);
      }, [L]), y(() => {
        var N;
        const D = $.current;
        if (typeof process < "u", P === oe) {
          D == null || D.unsubscribe(), $.current = void 0;
          return;
        }
        const K = (N = $.current) == null ? void 0 : N.subscriptionOptions;
        if (!D || D.arg !== P) {
          D == null || D.unsubscribe();
          const U = T(O(P, {
            subscriptionOptions: M,
            forceRefetch: b
          }));
          $.current = U;
        } else M !== K && D.updateSubscriptionOptions(M);
      }, [T, O, b, P, M, L]), F.useEffect(() => () => {
        var D;
        (D = $.current) == null || D.unsubscribe(), $.current = void 0;
      }, []), F.useMemo(() => ({
        /**
         * A method to manually refetch data for the query
         */
        refetch: () => {
          var D;
          if (!$.current) throw new Error(V(38));
          return (D = $.current) == null ? void 0 : D.refetch();
        }
      }), []);
    }, _ = ({
      refetchOnReconnect: m,
      refetchOnFocus: f,
      pollingInterval: p = 0,
      skipPollingIfUnfocused: b = !1
    } = {}) => {
      const {
        initiate: R
      } = e.endpoints[g], C = r(), [w, O] = F.useState(gt), T = F.useRef(void 0), E = mt({
        refetchOnReconnect: m,
        refetchOnFocus: f,
        pollingInterval: p,
        skipPollingIfUnfocused: b
      });
      y(() => {
        var $, x;
        const k = ($ = T.current) == null ? void 0 : $.subscriptionOptions;
        E !== k && ((x = T.current) == null || x.updateSubscriptionOptions(E));
      }, [E]);
      const P = F.useRef(E);
      y(() => {
        P.current = E;
      }, [E]);
      const M = F.useCallback(function(k, $ = !1) {
        let x;
        return t(() => {
          var Q;
          (Q = T.current) == null || Q.unsubscribe(), T.current = x = C(R(k, {
            subscriptionOptions: P.current,
            forceRefetch: !$
          })), O(k);
        }), x;
      }, [C, R]);
      return F.useEffect(() => () => {
        var k;
        (k = T == null ? void 0 : T.current) == null || k.unsubscribe();
      }, []), F.useEffect(() => {
        w !== gt && !T.current && M(w, !0);
      }, [w, M]), F.useMemo(() => [M, w], [M, w]);
    }, S = (m, {
      skip: f = !1,
      selectFromResult: p
    } = {}) => {
      const {
        select: b
      } = e.endpoints[g], R = Mr(f ? oe : m, c, o.endpointDefinitions[g], g), C = F.useRef(void 0), w = F.useMemo(() => u([b(R), (M, k) => k, (M) => R], l, {
        memoizeOptions: {
          resultEqualityCheck: Se
        }
      }), [b, R]), O = F.useMemo(() => p ? u([w], p, {
        devModeChecks: {
          identityFunctionCheck: "never"
        }
      }) : w, [w, p]), T = n((M) => O(M, C.current), Se), E = i(), P = w(E.getState(), C.current);
      return as(() => {
        C.current = P;
      }, [P]), T;
    };
    return {
      useQueryState: S,
      useQuerySubscription: v,
      useLazyQuerySubscription: _,
      useLazyQuery(m) {
        const [f, p] = _(m), b = S(p, {
          ...m,
          skip: p === gt
        }), R = F.useMemo(() => ({
          lastArg: p
        }), [p]);
        return F.useMemo(() => [f, b, R], [f, b, R]);
      },
      useQuery(m, f) {
        const p = v(m, f), b = S(m, {
          selectFromResult: m === oe || f != null && f.skip ? void 0 : us,
          ...f
        }), {
          data: R,
          status: C,
          isLoading: w,
          isSuccess: O,
          isError: T,
          error: E
        } = b;
        return F.useDebugValue({
          data: R,
          status: C,
          isLoading: w,
          isSuccess: O,
          isError: T,
          error: E
        }), F.useMemo(() => ({
          ...b,
          ...p
        }), [b, p]);
      }
    };
  }
  function d(g) {
    return ({
      selectFromResult: v,
      fixedCacheKey: _
    } = {}) => {
      const {
        select: S,
        initiate: m
      } = e.endpoints[g], f = r(), [p, b] = F.useState();
      F.useEffect(() => () => {
        p != null && p.arg.fixedCacheKey || p == null || p.reset();
      }, [p]);
      const R = F.useCallback(function(K) {
        const N = f(m(K, {
          fixedCacheKey: _
        }));
        return b(N), N;
      }, [f, m, _]), {
        requestId: C
      } = p || {}, w = F.useMemo(() => S({
        fixedCacheKey: _,
        requestId: p == null ? void 0 : p.requestId
      }), [_, p, S]), O = F.useMemo(() => v ? u([w], v) : w, [v, w]), T = n(O, Se), E = _ == null ? p == null ? void 0 : p.arg.originalArgs : void 0, P = F.useCallback(() => {
        t(() => {
          p && b(void 0), _ && f(e.internalActions.removeMutationResult({
            requestId: C,
            fixedCacheKey: _
          }));
        });
      }, [f, _, p, C]), {
        endpointName: M,
        data: k,
        status: $,
        isLoading: x,
        isSuccess: Q,
        isError: q,
        error: L
      } = T;
      F.useDebugValue({
        endpointName: M,
        data: k,
        status: $,
        isLoading: x,
        isSuccess: Q,
        isError: q,
        error: L
      });
      const D = F.useMemo(() => ({
        ...T,
        originalArgs: E,
        reset: P
      }), [T, E, P]);
      return F.useMemo(() => [R, D], [R, D]);
    };
  }
}
var fs = /* @__PURE__ */ Symbol(), ls = ({
  batch: e = Zo,
  hooks: t = {
    useDispatch: Xo,
    useSelector: Ho,
    useStore: yn
  },
  createSelector: r = ye,
  unstable__sideEffectsInRender: n = !1,
  ...i
} = {}) => ({
  name: fs,
  init(s, {
    serializeQueryArgs: u
  }, c) {
    const o = s, {
      buildQueryHooks: y,
      buildMutationHook: l,
      usePrefetch: h
    } = cs({
      api: s,
      moduleOptions: {
        batch: e,
        hooks: t,
        unstable__sideEffectsInRender: n,
        createSelector: r
      },
      serializeQueryArgs: u,
      context: c
    });
    return We(o, {
      usePrefetch: h
    }), We(c, {
      batch: e
    }), {
      injectEndpoint(a, d) {
        if (jo(d)) {
          const {
            useQuery: g,
            useLazyQuery: v,
            useLazyQuerySubscription: _,
            useQueryState: S,
            useQuerySubscription: m
          } = y(a);
          We(o.endpoints[a], {
            useQuery: g,
            useLazyQuery: v,
            useLazyQuerySubscription: _,
            useQueryState: S,
            useQuerySubscription: m
          }), s[`use${ht(a)}Query`] = g, s[`useLazy${ht(a)}Query`] = v;
        } else if (es(d)) {
          const g = l(a);
          We(o.endpoints[a], {
            useMutation: g
          }), s[`use${ht(a)}Mutation`] = g;
        }
      }
    };
  }
}), J = /* @__PURE__ */ io(mo(), ls());
const ds = J({
  reducerPath: "caps",
  baseQuery: G({
    prepareHeaders: (e, { getState: t }) => {
      const r = t().config.apiKey;
      return r && e.set("Authorization", `Bearer ${r}`), e;
    }
  }),
  endpoints: (e) => ({
    getCaps: e.query({
      queryFn: async (t, r, n, i) => {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${bi}`, o = await i({
          url: c,
          credentials: "same-origin",
          redirect: "follow"
        });
        return o.error ? { error: o.error } : ps(o.data) ? { data: o.data } : {
          meta: o.meta,
          error: {
            error: "Invalid response from caps",
            data: o.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    })
  }),
  refetchOnMountOrArgChange: !0
});
ds.endpoints;
function ps(e) {
  return !(!e || typeof e != "object" || !("code_chat_default_model" in e) || typeof e.code_chat_default_model != "string" || !("code_chat_models" in e));
}
const ys = 4096;
function hs(e) {
  return !(!e || typeof e != "object" || !("role" in e) || typeof e.role != "string" || !("content" in e) || e.content !== null && typeof e.content != "string");
}
async function gs({
  messages: e,
  model: t,
  abortSignal: r,
  stream: n,
  max_new_tokens: i,
  // lspUrl,
  // takeNote = false,
  onlyDeterministicMessages: s,
  chatId: u,
  tools: c,
  port: o = 8001,
  apiKey: y,
  toolsConfirmed: l = !0,
  checkpointsEnabled: h = !0,
  // isConfig = false,
  integration: a,
  last_user_message_id: d = "",
  mode: g
}) {
  const v = JSON.stringify({
    messages: e,
    model: t,
    stream: n,
    tools: c,
    max_tokens: i,
    only_deterministic_messages: s,
    tools_confirmation: l,
    checkpoints_enabled: h,
    // chat_id,
    meta: {
      chat_id: u,
      request_attempt_id: d,
      // chat_remote,
      // TODO: pass this through
      chat_mode: g ?? "EXPLORE",
      // chat_mode: "EXPLORE", // NOTOOLS, EXPLORE, AGENT, CONFIGURE, PROJECTSUMMARY,
      // TODO: not clear, that if we set integration.path it's going to be set also in meta as current_config_file
      ...a != null && a.path ? { current_config_file: a.path } : {}
    }
  }), _ = {
    "Content-Type": "application/json",
    ...y ? { Authorization: "Bearer " + y } : {}
  }, S = `http://127.0.0.1:${o}${Wr}`;
  return fetch(S, {
    method: "POST",
    headers: _,
    body: v,
    redirect: "follow",
    cache: "no-cache",
    // TODO: causes an error during tests :/
    // referrer: "no-referrer",
    signal: r,
    credentials: "same-origin"
  });
}
async function ms({
  messages: e,
  model: t,
  stream: r,
  onlyDeterministicMessages: n,
  chatId: i,
  port: s = 8001,
  apiKey: u
}) {
  const c = JSON.stringify({
    messages: e,
    model: t,
    stream: r,
    max_tokens: 300,
    only_deterministic_messages: n,
    chat_id: i
  }), o = {
    "Content-Type": "application/json",
    ...u ? { Authorization: "Bearer " + u } : {}
  }, y = `http://127.0.0.1:${s}${Wr}`;
  return fetch(y, {
    method: "POST",
    headers: o,
    body: c,
    redirect: "follow",
    cache: "no-cache",
    // TODO: causes an error during tests :/
    // referrer: "no-referrer",
    credentials: "same-origin"
  });
}
/*! js-cookie v3.0.5 | MIT */
function Be(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t];
    for (var n in r)
      e[n] = r[n];
  }
  return e;
}
var _s = {
  read: function(e) {
    return e[0] === '"' && (e = e.slice(1, -1)), e.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
  },
  write: function(e) {
    return encodeURIComponent(e).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    );
  }
};
function kt(e, t) {
  function r(i, s, u) {
    if (!(typeof document > "u")) {
      u = Be({}, t, u), typeof u.expires == "number" && (u.expires = new Date(Date.now() + u.expires * 864e5)), u.expires && (u.expires = u.expires.toUTCString()), i = encodeURIComponent(i).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
      var c = "";
      for (var o in u)
        u[o] && (c += "; " + o, u[o] !== !0 && (c += "=" + u[o].split(";")[0]));
      return document.cookie = i + "=" + e.write(s, i) + c;
    }
  }
  function n(i) {
    if (!(typeof document > "u" || arguments.length && !i)) {
      for (var s = document.cookie ? document.cookie.split("; ") : [], u = {}, c = 0; c < s.length; c++) {
        var o = s[c].split("="), y = o.slice(1).join("=");
        try {
          var l = decodeURIComponent(o[0]);
          if (u[l] = e.read(y, l), i === l)
            break;
        } catch {
        }
      }
      return i ? u[i] : u;
    }
  }
  return Object.create(
    {
      set: r,
      get: n,
      remove: function(i, s) {
        r(
          i,
          "",
          Be({}, s, {
            expires: -1
          })
        );
      },
      withAttributes: function(i) {
        return kt(this.converter, Be({}, this.attributes, i));
      },
      withConverter: function(i) {
        return kt(Be({}, this.converter, i), this.attributes);
      }
    },
    {
      attributes: { value: Object.freeze(t) },
      converter: { value: Object.freeze(e) }
    }
  );
}
kt(_s, { path: "/" });
function st(e, t, r) {
  try {
    const n = JSON.parse(e);
    return r && !r(n) ? t : n;
  } catch {
    return t;
  }
}
function hn(e, t, r = []) {
  if (e.length === 0) return r;
  const n = e.slice(-1)[0];
  if (!t(n)) return r;
  const i = e.slice(0, -1);
  return hn(i, t, [n, ...r]);
}
function vs(e, t) {
  return hn(e, t);
}
function gn(e, t) {
  if (e.length === 0 || e.length === 1) return !1;
  const [r, ...n] = e;
  return n.some((s) => t(r, s)) ? !0 : gn(n, t);
}
J({
  reducerPath: "commands",
  baseQuery: G({
    prepareHeaders: (e, t) => {
      const r = t.getState, i = r().config.apiKey;
      return i && e.set("Authorization", `Bearer ${i}`), e;
    }
  }),
  endpoints: (e) => ({
    getCommandCompletion: e.query({
      queryFn: async (t, r, n, i) => {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Ci}`, o = await i({
          url: c,
          method: "POST",
          credentials: "same-origin",
          redirect: "follow",
          body: {
            query: t.query,
            cursor: t.cursor,
            top_n: t.top_n ?? 5
          }
        }), y = "@help".startsWith(t.query) && t.query.length !== 0 ? ["@help"] : [];
        return o.error ? { error: o.error } : bs(o.data) ? {
          data: {
            ...o.data,
            completions: [
              ...y,
              ...o.data.completions
            ]
          }
        } : Ye(o.data) ? {
          data: {
            completions: [...y],
            replace: [0, 0],
            is_cmd_executable: !1
          }
        } : {
          error: {
            error: "Invalid response from command completion",
            data: o.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    }),
    getCommandPreview: e.query({
      queryFn: async (t, r, n, i) => {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Ri}`, o = await i({
          url: c,
          method: "POST",
          credentials: "same-origin",
          redirect: "follow",
          body: { query: t }
        });
        return o.error ? { error: o.error } : !Cs(o.data) && !Ye(o.data) ? {
          error: {
            data: o.data,
            status: "CUSTOM_ERROR",
            error: "Invalid response from command preview"
          }
        } : Ye(o.data) ? { data: [] } : { data: o.data.messages.reduce((l, h) => {
          if (h.role === "context_file") {
            const a = st(h.content, []);
            return [...l, ...a];
          }
          return [...l, h.content];
        }, []) };
      }
    })
  }),
  refetchOnMountOrArgChange: !0
});
function bs(e) {
  return !(!e || typeof e != "object" || !("completions" in e) || !("replace" in e) || !("is_cmd_executable" in e));
}
function Ye(e) {
  return !(!e || typeof e != "object" || !("detail" in e));
}
function Ss(e) {
  return !e || typeof e != "object" || !("content" in e) || typeof e.content != "string" || !("role" in e) ? !1 : e.role === "context_file" || e.role === "plain_text";
}
function Cs(e) {
  return !e || typeof e != "object" || !("messages" in e) || !Array.isArray(e.messages) ? !1 : e.messages.length ? e.messages.some(Ss) : !0;
}
const Rs = J({
  reducerPath: "prompts",
  baseQuery: G({
    prepareHeaders: (e, t) => {
      const r = t.getState, i = r().config.apiKey;
      return i && e.set("Authorization", `Bearer ${i}`), e;
    }
  }),
  endpoints: (e) => ({
    getPrompts: e.query({
      queryFn: async (t, r, n, i) => {
        const s = r.getState, o = `http://127.0.0.1:${s().config.lspPort}${wi}`, y = await i({
          url: o,
          credentials: "same-origin",
          redirect: "follow"
        });
        return y.error ? {
          error: y.error
        } : Ts(y.data) ? { data: y.data.system_prompts } : {
          error: {
            data: y.data,
            error: "Invalid response from server",
            status: "CUSTOM_ERROR"
          }
        };
      }
    })
  })
});
Rs.endpoints;
function ws(e) {
  return !(!e || typeof e != "object" || !("text" in e) || !("description" in e));
}
function Os(e) {
  if (!e || typeof e != "object") return !1;
  for (const t of Object.values(e))
    if (!ws(t)) return !1;
  return !0;
}
function Ts(e) {
  return !e || typeof e != "object" || !("system_prompts" in e) || typeof e.system_prompts != "object" || e.system_prompts === null ? !1 : Os(e.system_prompts);
}
J({
  reducerPath: "statisticsApi",
  baseQuery: G({
    prepareHeaders: (e, t) => {
      const r = t.getState, i = r().config.apiKey;
      return i && e.set("Authorization", `Bearer ${i}`), e;
    }
  }),
  endpoints: (e) => ({
    getStatisticData: e.query({
      queryFn: async (t, r, n, i) => {
        const s = r.getState, o = `http://127.0.0.1:${s().config.lspPort}${Si}`, y = await i({
          url: o,
          credentials: "same-origin",
          redirect: "follow"
        });
        if (y.error) return { error: y.error };
        if (!Es(y.data))
          return {
            error: {
              data: y.data,
              error: "Invalid response from server",
              status: "CUSTOM_ERROR"
            }
          };
        try {
          return { data: JSON.parse(y.data.data) };
        } catch {
          return {
            error: {
              data: y.data.data,
              error: "Invalid response from server",
              originalStatus: 200,
              status: "PARSING_ERROR"
            }
          };
        }
      }
    })
  }),
  refetchOnMountOrArgChange: !0
});
function Es(e) {
  return !e || typeof e != "object" || !("data" in e) ? !1 : typeof e.data == "string";
}
J({
  reducerPath: "tools",
  baseQuery: G({
    prepareHeaders: (e, t) => {
      const r = t.getState, i = r().config.apiKey;
      return i && e.set("Authorization", `Bearer ${i}`), e;
    }
  }),
  endpoints: (e) => ({
    getTools: e.query({
      queryFn: async (t, r, n, i) => {
        const s = r.getState, o = `http://127.0.0.1:${s().config.lspPort}${Oi}`, y = await i({
          url: o,
          credentials: "same-origin",
          redirect: "follow"
        });
        return y.error ? y : Array.isArray(y.data) ? { data: y.data.filter(
          (h) => As(h)
        ) } : {
          error: {
            error: "Invalid response from tools",
            data: y.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    }),
    checkForConfirmation: e.mutation({
      queryFn: async (t, r, n, i) => {
        const s = r.getState, c = s().config.lspPort, { messages: o, tool_calls: y } = t, l = qe(o), h = `http://127.0.0.1:${c}${Ti}`, a = await i({
          url: h,
          method: "POST",
          body: {
            tool_calls: y,
            messages: l
          },
          credentials: "same-origin",
          redirect: "follow"
        });
        return a.error ? a : Ps(a.data) ? { data: a.data } : {
          error: {
            error: "Invalid response from tools",
            data: a.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    }),
    dryRunForEditTool: e.mutation({
      async queryFn(t, r, n, i) {
        const s = r.getState, o = `http://127.0.0.1:${s().config.lspPort}${ur}`, y = await i({
          ...n,
          url: o,
          method: "POST",
          body: { tool_name: t.toolName, tool_args: t.toolArgs },
          credentials: "same-origin",
          redirect: "follow"
        });
        return y.error ? y : Ms(y.data) ? { data: y.data } : {
          error: {
            error: `Invalid response from ${ur}`,
            data: y.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    })
  }),
  refetchOnMountOrArgChange: !0
});
function As(e) {
  return !(!e || typeof e != "object" || !("type" in e) || !("function" in e));
}
function Ps(e) {
  if (!e || typeof e != "object") return !1;
  const t = e;
  if (typeof t.pause != "boolean" || !Array.isArray(t.pause_reasons)) return !1;
  for (const r of t.pause_reasons)
    if (typeof r.type != "string" || typeof r.command != "string" || typeof r.rule != "string" || typeof r.tool_call_id != "string") return !1;
  return !0;
}
function Ms(e) {
  return !e || typeof e != "object" || !("file_before" in e) || typeof e.file_before != "string" || !("file_after" in e) || typeof e.file_after != "string" || !("chunks" in e) || !Array.isArray(e.chunks) ? !1 : e.chunks.every(yi);
}
async function He(e, t, r, n, i) {
  const c = `http://127.0.0.1:${e.getState().config.lspPort}${n}`, o = await t(
    {
      url: c,
      method: "GET",
      ...r,
      responseHandler: "text"
    },
    e,
    r
  );
  return o.error ? o : typeof o.data != "string" ? {
    error: {
      error: `${i} path response not a string`,
      status: "CUSTOM_ERROR"
    }
  } : { data: o.data + i };
}
J({
  reducerPath: "pathApi",
  baseQuery: G({
    prepareHeaders: (e, { getState: t }) => {
      const r = t().config.apiKey;
      return r && e.set("Authorization", `Bearer ${r}`), e;
    }
  }),
  endpoints: (e) => ({
    getFullPath: e.query({
      queryFn: async (t, r, n, i) => {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Ei}`, o = await i({
          url: c,
          credentials: "same-origin",
          redirect: "follow",
          method: "POST",
          body: { path: t }
        });
        return o.error ? { error: o.error } : ks(o.data) ? o.data.is_directory ? { data: null } : { data: o.data.fullpath } : {
          meta: o.meta,
          error: {
            error: "Invalid response from fullpath",
            data: o.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    }),
    customizationPath: e.query({
      queryFn: async (t, r, n, i) => await He(
        r,
        i,
        n,
        Le,
        "/customization.yaml"
      )
    }),
    privacyPath: e.query({
      queryFn: async (t, r, n, i) => await He(
        r,
        i,
        n,
        Le,
        "/privacy.yaml"
      )
    }),
    bringYourOwnKeyPath: e.query({
      queryFn: async (t, r, n, i) => await He(
        r,
        i,
        n,
        Le,
        "/bring-your-own-key.yaml"
      )
    }),
    integrationsPath: e.query({
      queryFn: async (t, r, n, i) => await He(
        r,
        i,
        n,
        Le,
        "/integrations.yaml"
      )
    })
  })
});
function ks(e) {
  return !(typeof e != "object" || e === null || !("fullpath" in e) || !("is_directory" in e) || typeof e.fullpath != "string" || typeof e.is_directory != "boolean");
}
J({
  reducerPath: "pingApi",
  baseQuery: G({ baseUrl: cr }),
  tagTypes: ["PING"],
  endpoints: (e) => ({
    ping: e.query({
      providesTags: () => ["PING"],
      queryFn: async (t, r, n, i) => {
        const u = `http://127.0.0.1:${r.getState().config.lspPort}${cr}`;
        return new Promise((c, o) => {
          const y = () => {
            fetch(u, {
              method: "GET",
              redirect: "follow",
              cache: "no-cache"
            }).then((l) => {
              if (l.ok) return l.text();
              throw new Error(l.statusText);
            }).then((l) => {
              c({ data: l });
            }).catch((l) => {
              if (l.message === "Failed to fetch")
                setTimeout(y, 1e3);
              else {
                const h = {
                  status: "FETCH_ERROR",
                  error: l.message
                };
                c({ error: h });
              }
            });
          };
          y();
        });
      }
    }),
    reset: e.mutation({
      queryFn: () => ({ data: null }),
      invalidatesTags: ["PING"]
    })
  })
});
function Fs(e) {
  return !e || typeof e != "object" || !("link_action" in e) || typeof e.link_action != "string" || !("link_text" in e) || typeof e.link_text != "string" || "link_goto" in e && typeof e.link_goto != "string" ? !1 : e.link_action === "post-chat" ? Is(e) : !0;
}
function Is(e) {
  return "link_action" in e && e.link_action === "post-chat" && "link_payload" in e && typeof e.link_payload == "object" && e.link_payload !== null && "chat_meta" in e.link_payload && "messages" in e.link_payload;
}
function Ds(e) {
  return !e || typeof e != "object" || !("links" in e) || !Array.isArray(e.links) ? !1 : e.links.every(Fs);
}
J({
  reducerPath: "linksApi",
  tagTypes: ["Chat_Links"],
  baseQuery: G({
    prepareHeaders: (e, { getState: t }) => {
      const r = t().config.apiKey;
      return r && e.set("Authorization", `Bearer ${r}`), e;
    }
  }),
  endpoints: (e) => ({
    getLinksForChat: e.query({
      providesTags: ["Chat_Links"],
      async queryFn(t, r, n, i) {
        const u = r.getState().config.lspPort, c = qe(t.messages), o = await i({
          ...n,
          method: "POST",
          url: `http://127.0.0.1:${u}${Ai}`,
          body: {
            meta: {
              chat_id: t.chat_id,
              current: t.current_config_file,
              chat_mode: t.mode
            },
            messages: c,
            model_name: t.model
          }
        });
        return o.error ? { error: o.error } : Ds(o.data) ? { data: o.data } : {
          error: {
            error: "Invalid response for chat links",
            data: o.data,
            status: "CUSTOM_ERROR"
          }
        };
      }
    }),
    sendCommit: e.mutation({
      invalidatesTags: ["Chat_Links"],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Pi}`, o = await i({
          ...n,
          method: "POST",
          url: c,
          body: t
        });
        return o.error ? { error: o.error } : $s(o.data) ? { data: o.data } : {
          error: {
            status: "CUSTOM_ERROR",
            data: o.data,
            error: "Invalid response for commit"
          }
        };
      }
    })
  })
});
function $s(e) {
  return !(!e || typeof e != "object" || !("commits_applied" in e) || !Array.isArray(e.commits_applied) || !("error_log" in e) || !Array.isArray(e.error_log));
}
J({
  reducerPath: "integrationsApi",
  tagTypes: ["INTEGRATIONS", "INTEGRATION"],
  baseQuery: G({
    prepareHeaders: (e, t) => {
      const r = t.getState, i = r().config.apiKey;
      return e.set("credentials", "same-origin"), i && e.set("Authorization", `Bearer ${i}`), e;
    }
  }),
  endpoints: (e) => ({
    getAllIntegrations: e.query({
      providesTags: ["INTEGRATIONS"],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Mi}`, o = await i({
          url: c,
          ...n
        });
        return o.error ? { error: o.error } : Qs(o.data) ? { data: o.data } : {
          error: {
            status: "CUSTOM_ERROR",
            error: "Failed to parse integrations response",
            data: o.data
          }
        };
      }
    }),
    getIntegrationByPath: e.query({
      providesTags: (t, r, n) => [
        { type: "INTEGRATION", id: n }
      ],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${ki}`, o = await i({
          url: c,
          method: "POST",
          body: {
            integr_config_path: t
          },
          ...n
        });
        return o.error ? { error: o.error } : qs(o.data) ? {
          data: o.data
        } : {
          error: {
            status: "CUSTOM_ERROR",
            error: "Failed to parse integration response for: " + t,
            data: o.data
          }
        };
      }
    }),
    saveIntegration: e.mutation({
      invalidatesTags: (t, r, n) => [
        { type: "INTEGRATION", id: n.filePath }
      ],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Fi}`;
        return await i({
          ...n,
          url: c,
          method: "POST",
          body: {
            integr_config_path: t.filePath,
            integr_values: t.values
          }
        });
      }
    }),
    deleteIntegration: e.query({
      providesTags: (t, r, n) => [
        { type: "INTEGRATION", id: n }
      ],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Ii}?integration_path=${t}`, o = await i({
          ...n,
          url: c,
          method: "DELETE"
        });
        return o.error ? { error: o.error } : Ye(o.data) ? {
          error: {
            status: "CUSTOM_ERROR",
            error: `Failed to delete integration by path: ${t}. Details: ${o.data.detail}`,
            data: o.data
          }
        } : {
          data: o.data
        };
      }
    })
  })
});
function Ce(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || e === null;
}
function qs(e) {
  if (!e || typeof e != "object" || !("project_path" in e) || typeof e.project_path != "string" || !("integr_name" in e) || typeof e.integr_name != "string" || !("integr_config_path" in e) || typeof e.integr_config_path != "string" || !("integr_schema" in e) || !Us(e.integr_schema) || !("integr_values" in e) || e.integr_values !== null && typeof e.integr_values != "object")
    return !1;
  const t = e.integr_values;
  function r(n) {
    return Ce(n) ? !0 : typeof n == "object" && n !== null ? Object.values(n).every(r) : !1;
  }
  return !(t && !Object.values(t).every(r) || !("error_log" in e) || !e.error_log || typeof e.error_log != "object" || !Array.isArray(e.error_log) || !e.error_log.every(mn));
}
function xs(e) {
  return !(!e || typeof e != "object" || !("filter_label" in e) || typeof e.filter_label != "string" || !("filter_image" in e) || typeof e.filter_image != "string");
}
function Ns(e) {
  return !(!e || typeof e != "object" || !("image" in e) || typeof e.image != "string" || !("environment" in e) || !e.environment || typeof e.environment != "object" || !Object.values(e.environment).every(Ce));
}
function Us(e) {
  return !(!e || typeof e != "object" || "description" in e && typeof e.description != "string" || !("fields" in e) || !e.fields || typeof e.fields != "object" || !Object.values(e.fields).every(Ls) || !("confirmation" in e) || !e.confirmation || typeof e.confirmation != "object" || !("available" in e) || !e.available || typeof e.available != "object" || !Object.values(e.available).every((t) => typeof t == "boolean") || "smartlinks" in e && (!e.smartlinks || !Array.isArray(e.smartlinks) || !e.smartlinks.every(_t)) || "docker" in e && (!e.docker || typeof e.docker != "object" || !xs(e.docker) || !("new_container_default" in e.docker) || !Ns(e.docker.new_container_default) || !("smartlinks" in e.docker) || !Array.isArray(e.docker.smartlinks) || !e.docker.smartlinks.every(_t) || "smartlinks_for_each_container" in e.docker && (!Array.isArray(e.docker.smartlinks_for_each_container) || !e.docker.smartlinks_for_each_container.every(_t))));
}
function Ls(e) {
  return !(!e || typeof e != "object" || !("f_type" in e) || !Ce(e.f_type) || "f_desc" in e && typeof e.f_desc != "string" || "f_label" in e && typeof e.f_label != "string" || "f_extra" in e && typeof e.f_extra != "boolean" || "f_placeholder" in e && !Ce(e.f_placeholder) || "f_default" in e && !Ce(e.f_default) || "smartlinks" in e && !Array.isArray(e.smartlinks));
}
function _t(e) {
  return !(!e || typeof e != "object" || !("sl_label" in e) || typeof e.sl_label != "string" || !("sl_chat" in e) || "sl_enable_only_with_tool" in e && typeof e.sl_enable_only_with_tool != "boolean" || !Array.isArray(e.sl_chat) || !e.sl_chat.every(hs));
}
function zs(e) {
  return !(!e || typeof e != "object" || !("project_path" in e) || typeof e.project_path != "string" || !("integr_name" in e) || typeof e.integr_name != "string" || !("icon_path" in e) || typeof e.icon_path != "string" || !("integr_config_path" in e) || typeof e.integr_config_path != "string" || !("integr_config_exists" in e) || typeof e.integr_config_exists != "boolean" || !("on_your_laptop" in e) || typeof e.on_your_laptop != "boolean" || !("when_isolated" in e) || typeof e.when_isolated != "boolean");
}
function mn(e) {
  return !(!e || typeof e != "object" || !("integr_config_path" in e) || typeof e.integr_config_path != "string" || !("error_line" in e) || typeof e.error_line != "number" || !("error_msg" in e) || typeof e.error_msg != "string");
}
function Qs(e) {
  return !(!e || typeof e != "object" || !("integrations" in e) || !Array.isArray(e.integrations) || !e.integrations.every(zs) || !("error_log" in e) || !Array.isArray(e.error_log) || !e.error_log.every(mn));
}
J({
  reducerPath: "dockerApi",
  tagTypes: ["DOCKER"],
  baseQuery: G({
    prepareHeaders: (e, t) => {
      const r = t.getState, i = r().config.apiKey;
      return e.set("credentials", "same-origin"), i && e.set("Authorization", `Bearer ${i}`), e;
    }
  }),
  endpoints: (e) => ({
    getAllDockerContainers: e.query({
      // TODO: make a function for settings tags
      providesTags: ["DOCKER"],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${ze}`, o = await i({
          url: c,
          // LSP cannot handle regular GET request :/
          method: "POST",
          body: {},
          ...n
        });
        return o.error ? { error: o.error } : Ve(o.data) ? { data: o.data } : {
          error: {
            status: "CUSTOM_ERROR",
            error: "Failed to parse docker containers response",
            data: o.data
          }
        };
      }
    }),
    getDockerContainersByLabel: e.query(
      {
        providesTags: ["DOCKER"],
        async queryFn(t, r, n, i) {
          const c = `http://127.0.0.1:${r.getState().config.lspPort}${ze}`, o = await i({
            url: c,
            method: "POST",
            body: {
              label: t
            },
            ...n
          });
          return o.error ? { error: o.error } : Ve(o.data) ? { data: o.data } : {
            error: {
              status: "CUSTOM_ERROR",
              error: "Failed to parse docker containers by labels response",
              data: o.data
            }
          };
        }
      }
    ),
    getDockerContainersByImage: e.query(
      {
        providesTags: ["DOCKER"],
        async queryFn(t, r, n, i) {
          const c = `http://127.0.0.1:${r.getState().config.lspPort}${ze}`, o = await i({
            url: c,
            method: "POST",
            body: {
              image: t
            },
            ...n
          });
          return o.error ? { error: o.error } : Ve(o.data) ? { data: o.data } : {
            error: {
              status: "CUSTOM_ERROR",
              error: "Failed to parse docker containers by images response",
              data: o.data
            }
          };
        }
      }
    ),
    getDockerContainersByImageAndLabel: e.query({
      providesTags: ["DOCKER"],
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${ze}`, o = await i({
          url: c,
          method: "POST",
          body: {
            image: t.image,
            label: t.label
          },
          ...n
        });
        return o.error ? { error: o.error } : Ve(o.data) ? { data: o.data } : {
          error: {
            status: "CUSTOM_ERROR",
            error: "Failed to parse docker containers by images response",
            data: o.data
          }
        };
      }
    }),
    executeActionForDockerContainer: e.mutation({
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Di}`, o = await i({
          url: c,
          method: "POST",
          body: {
            action: t.action,
            container: t.container
          },
          ...n
        });
        return o.error ? {
          error: {
            status: "CUSTOM_ERROR",
            error: `Failed to execute ${t.action} for docker container with ${t.container} name/id!`,
            data: o.error.data
          }
        } : Ks(o.data) ? { data: o.data } : {
          error: {
            status: "CUSTOM_ERROR",
            error: `Failed to execute ${t.action} for docker container with ${t.container} name/id!`,
            data: o.data
          }
        };
      }
    })
  })
});
function Ks(e) {
  return !(!e || typeof e != "object" || !("success" in e) || typeof e.success != "boolean" || !("output" in e) || typeof e.output != "string");
}
function Ve(e) {
  return !(!e || typeof e != "object" || !Array.isArray(e.containers) || !e.containers.every(Ws) || "has_connection_to_docker_daemon" in e && typeof e.has_connection_to_docker_daemon != "boolean" || "docker_error" in e && typeof e.docker_error != "string");
}
function Ws(e) {
  if (!e || typeof e != "object") return !1;
  const t = e;
  return !(typeof t.id != "string" || typeof t.name != "string" || typeof t.status != "string" || typeof t.created != "string" || typeof t.user != "string" || !Array.isArray(t.env) || !t.env.every((r) => typeof r == "string") || !Array.isArray(t.command) || !t.command.every((r) => typeof r == "string") || typeof t.image != "string" || typeof t.working_dir != "string" || !Bs(t.labels) || !Hs(t.ports));
}
function Bs(e) {
  return e != null;
}
function Hs(e) {
  return e != null;
}
J({
  reducerPath: "telemetryApi",
  baseQuery: G({
    prepareHeaders: (e, { getState: t }) => {
      const r = t().config.apiKey;
      return r && e.set("Authorization", `Bearer ${r}`), e;
    }
  }),
  endpoints: (e) => ({
    sendTelemetryChatEvent: e.query({
      async queryFn(t, r, n, i) {
        const u = r.getState().config.lspPort, c = `http://127.0.0.1:${u}${$i}`, o = await i({
          ...n,
          url: c,
          method: "POST",
          body: t
        });
        return o.error ? { data: (await i({
          ...n,
          url: `http://127.0.0.1:${u}${pt}`,
          method: "POST",
          body: { ...t, url: pt }
        })).data } : { data: o.data };
      }
    }),
    sendTelemetryNetEvent: e.query({
      async queryFn(t, r, n, i) {
        const u = r.getState().config.lspPort;
        return { data: (await i({
          ...n,
          url: `http://127.0.0.1:${u}${pt}`,
          method: "POST",
          body: { ...t }
        })).data };
      }
    })
  })
});
const Vs = {
  loaded: !1,
  memories: {},
  status: null
}, _n = ie({
  name: "knowledge",
  initialState: Vs,
  reducers: {
    // TODO: add reducers
    setVecDbStatus: (e, t) => {
      e.loaded = !0, e.status = t.payload;
    },
    setMemory: (e, t) => {
      e.loaded = !0, e.memories[t.payload.memid] = t.payload;
    },
    deleteMemory: (e, t) => {
      e.loaded = !0;
      const { [t.payload]: r, ...n } = e.memories;
      e.memories = n;
    },
    clearMemory: (e) => {
      e.loaded = !0, e.memories = {};
    }
  },
  // TODO: selectors
  selectors: {
    selectVecDbStatus: (e) => e.status,
    selectMemories: (e) => e.memories,
    selectKnowledgeIsLoaded: (e) => e.loaded
  }
}), { setVecDbStatus: Gs, setMemory: Js, deleteMemory: Ys, clearMemory: Xs } = _n.actions;
_n.selectors;
function Zs(e) {
  return !(!e || typeof e != "object" || !("pubevent_id" in e) || typeof e.pubevent_id != "number" || !("pubevent_action" in e) || typeof e.pubevent_action != "string" || !("pubevent_json" in e) || !At(e.pubevent_json));
}
function js(e) {
  return !(!e || typeof e != "object" || !("pubevent_id" in e) || typeof e.pubevent_id != "number" || !("pubevent_action" in e) || typeof e.pubevent_action != "string" || !("pubevent_json" in e) || typeof e.pubevent_json != "string");
}
function ea(e = 8001, t, r, n) {
  const i = `http://127.0.0.1:${e}${qi}`, s = new Headers();
  return s.append("Content-Type", "application/json"), r && s.append("Authorization", `Bearer ${r}`), fetch(i, {
    method: "POST",
    headers: s,
    redirect: "follow",
    cache: "no-cache",
    body: t ? JSON.stringify(t) : void 0,
    signal: n
  });
}
const ta = et.withTypes();
ta("knowledge/subscription", (e, t) => {
  const r = t.getState(), n = r.config.lspPort, i = r.config.apiKey;
  return ea(n, e, i, t.signal).then((s) => {
    var y;
    if (!s.ok)
      throw new Error(s.statusText);
    const u = (y = s.body) == null ? void 0 : y.getReader();
    if (!u) return;
    t.dispatch(Xs());
    const c = () => {
    }, o = (l) => {
      if (!Zs(l) && !js(l) && !ar(l)) {
        console.log("Invalid chunk from mem db", l);
        return;
      }
      if (ar(l)) {
        const a = Gs(l);
        t.dispatch(a);
        return;
      }
      const h = At(
        l.pubevent_json
      ) ? l.pubevent_json : st(l.pubevent_json, null, At);
      if (h !== null)
        if (l.pubevent_action === "DELETE") {
          const a = Ys(h.memid);
          t.dispatch(a);
        } else if (l.pubevent_action === "INSERT" || l.pubevent_action === "UPDATE") {
          const a = Js(h);
          t.dispatch(a);
        } else
          console.log("Unknown action", l.pubevent_action);
    };
    return Ht(u, t.signal, c, o);
  }).catch((s) => {
    console.error("Error in memory subscription", s);
  });
});
function ra(e) {
  return !(!e || typeof e != "object" || !("memid" in e) || typeof e.memid != "string");
}
function na(e) {
  return !(!e || typeof e != "object" || !("memid" in e) || typeof e.memid != "string" || !("trajectory" in e) || typeof e.trajectory != "string");
}
J({
  reducerPath: "knowledgeApi",
  baseQuery: G({
    prepareHeaders: (e, { getState: t }) => {
      const r = t().config.apiKey;
      return r && e.set("Authorization", `Bearer ${r}`), e;
    }
  }),
  endpoints: (e) => ({
    addMemory: e.mutation({
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${xi}`, o = await i({
          ...n,
          url: c,
          method: "POST",
          body: {
            mem_type: "",
            origin: "",
            project: "",
            ...t
          }
        });
        return o.error ? o : ra(o.data) ? { data: o.data, meta: o.meta } : {
          error: {
            status: "CUSTOM_ERROR",
            error: `Invalid response from ${c}`,
            data: o.data
          },
          meta: o.meta
        };
      }
    }),
    deleteMemory: e.mutation({
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Ni}`;
        return await i({
          ...n,
          url: c,
          method: "POST",
          body: { memid: t }
        });
      }
    }),
    updateMemory: e.mutation({
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Li}`;
        return await i({
          ...n,
          url: c,
          method: "POST",
          body: t
        });
      }
    }),
    updateMemoryUsage: e.mutation({
      async queryFn(t, r, n, i) {
        const c = `http://127.0.0.1:${r.getState().config.lspPort}${Ui}`;
        return await i({
          ...n,
          url: c,
          method: "POST",
          body: t
        });
      }
    }),
    createNewMemoryFromMessages: e.mutation({
      async queryFn(t, r, n, i) {
        const s = qe(t.messages), o = `http://127.0.0.1:${r.getState().config.lspPort}${zi}`, y = await i({
          ...n,
          url: o,
          method: "POST",
          body: { project: t.project, messages: s }
        });
        return y.error ? { error: y.error } : na(y.data) ? { data: y.data } : {
          error: {
            status: "CUSTOM_ERROR",
            error: `Invalid response from ${o}`,
            data: y.data
          }
        };
      }
    })
  })
});
function ia(e) {
  return !e || typeof e != "object" ? !1 : "detail" in e && typeof e.detail == "string";
}
function kr(e) {
  const t = st(e, {});
  return ia(t) ? t : !1;
}
function qe(e) {
  return e.reduce((t, r) => {
    if (hi(r))
      return t.concat([r]);
    if (xt(r))
      return t.concat([
        {
          role: r.role,
          content: r.content,
          tool_calls: r.tool_calls ?? void 0,
          finish_reason: r.finish_reason
        }
      ]);
    if (tt(r))
      return t.concat([
        {
          role: "tool",
          content: r.content.content,
          tool_call_id: r.content.tool_call_id
        }
      ]);
    if (gi(r)) {
      const i = {
        role: r.role,
        content: JSON.stringify(r.content),
        tool_call_id: r.tool_call_id
      };
      return t.concat([i]);
    }
    const n = typeof r.content == "string" ? r.content : JSON.stringify(r.content);
    return [...t, { role: r.role, content: n }];
  }, []);
}
function oa(e) {
  if (e.length < 8) return !1;
  const t = e[0] === 100 && // 'd'
  e[1] === 97 && // 'a'
  e[2] === 116 && // 't'
  e[3] === 97 && // 'a'
  e[4] === 58 && // ':'
  e[5] === 32, r = e[e.length - 2] === 10 && // '\n'
  e[e.length - 1] === 10;
  return t && r;
}
function sa(e) {
  return e[0] === 123 && // '{'
  e[1] === 34 && // '"'
  e[2] === 100 && // 'd'
  e[3] === 101 && // 'e'
  e[4] === 116 && // 't'
  e[5] === 97 && // 'a'
  e[6] === 105 && // 'i'
  e[7] === 108 && // 'l'
  e[8] === 34 && // '"'
  e[9] === 58;
}
function Ht(e, t, r, n) {
  const i = new TextDecoder();
  function s({
    done: u,
    value: c
  }) {
    if (u) return Promise.resolve();
    if (t.aborted)
      return r(), Promise.resolve();
    if (sa(c)) {
      const h = i.decode(c), a = kr(h);
      if (a)
        throw new Error(a.detail);
    }
    const o = () => e.read().then((h) => {
      if (h.done) return;
      const a = new Uint8Array(c.length + h.value.length);
      return a.set(c), a.set(h.value, c.length), s({ done: u, value: a });
    });
    if (!oa(c))
      return o();
    const l = i.decode(c).split(`

`).filter((h) => h.length > 0);
    if (l.length === 0) return Promise.resolve();
    for (const h of l) {
      if (!h.startsWith("data: ")) {
        console.log("Unexpected data in streaming buf: " + h);
        continue;
      }
      const a = h.substring(6);
      if (a === "[DONE]") return Promise.resolve();
      if (a === "[ERROR]") {
        const _ = "error from lsp", S = new Error(_);
        return Promise.reject(S);
      }
      const d = kr(a);
      if (d) {
        const _ = typeof d.detail == "string" ? d.detail : JSON.stringify(d.detail), S = new Error(_);
        throw console.error(S), S;
      }
      const g = {}, v = st(
        a,
        g
      );
      if (v === g)
        return o();
      n(v);
    }
    return e.read().then(s);
  }
  return e.read().then(s);
}
var Ft = { exports: {} }, vt, Fr;
function aa() {
  if (Fr) return vt;
  Fr = 1;
  var e = 1e3, t = e * 60, r = t * 60, n = r * 24, i = n * 7, s = n * 365.25;
  vt = function(l, h) {
    h = h || {};
    var a = typeof l;
    if (a === "string" && l.length > 0)
      return u(l);
    if (a === "number" && isFinite(l))
      return h.long ? o(l) : c(l);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(l)
    );
  };
  function u(l) {
    if (l = String(l), !(l.length > 100)) {
      var h = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        l
      );
      if (h) {
        var a = parseFloat(h[1]), d = (h[2] || "ms").toLowerCase();
        switch (d) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return a * s;
          case "weeks":
          case "week":
          case "w":
            return a * i;
          case "days":
          case "day":
          case "d":
            return a * n;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return a * r;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return a * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return a * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return a;
          default:
            return;
        }
      }
    }
  }
  function c(l) {
    var h = Math.abs(l);
    return h >= n ? Math.round(l / n) + "d" : h >= r ? Math.round(l / r) + "h" : h >= t ? Math.round(l / t) + "m" : h >= e ? Math.round(l / e) + "s" : l + "ms";
  }
  function o(l) {
    var h = Math.abs(l);
    return h >= n ? y(l, h, n, "day") : h >= r ? y(l, h, r, "hour") : h >= t ? y(l, h, t, "minute") : h >= e ? y(l, h, e, "second") : l + " ms";
  }
  function y(l, h, a, d) {
    var g = h >= a * 1.5;
    return Math.round(l / a) + " " + d + (g ? "s" : "");
  }
  return vt;
}
function ua(e) {
  r.debug = r, r.default = r, r.coerce = o, r.disable = s, r.enable = i, r.enabled = u, r.humanize = aa(), r.destroy = y, Object.keys(e).forEach((l) => {
    r[l] = e[l];
  }), r.names = [], r.skips = [], r.formatters = {};
  function t(l) {
    let h = 0;
    for (let a = 0; a < l.length; a++)
      h = (h << 5) - h + l.charCodeAt(a), h |= 0;
    return r.colors[Math.abs(h) % r.colors.length];
  }
  r.selectColor = t;
  function r(l) {
    let h, a = null, d, g;
    function v(..._) {
      if (!v.enabled)
        return;
      const S = v, m = Number(/* @__PURE__ */ new Date()), f = m - (h || m);
      S.diff = f, S.prev = h, S.curr = m, h = m, _[0] = r.coerce(_[0]), typeof _[0] != "string" && _.unshift("%O");
      let p = 0;
      _[0] = _[0].replace(/%([a-zA-Z%])/g, (R, C) => {
        if (R === "%%")
          return "%";
        p++;
        const w = r.formatters[C];
        if (typeof w == "function") {
          const O = _[p];
          R = w.call(S, O), _.splice(p, 1), p--;
        }
        return R;
      }), r.formatArgs.call(S, _), (S.log || r.log).apply(S, _);
    }
    return v.namespace = l, v.useColors = r.useColors(), v.color = r.selectColor(l), v.extend = n, v.destroy = r.destroy, Object.defineProperty(v, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => a !== null ? a : (d !== r.namespaces && (d = r.namespaces, g = r.enabled(l)), g),
      set: (_) => {
        a = _;
      }
    }), typeof r.init == "function" && r.init(v), v;
  }
  function n(l, h) {
    const a = r(this.namespace + (typeof h > "u" ? ":" : h) + l);
    return a.log = this.log, a;
  }
  function i(l) {
    r.save(l), r.namespaces = l, r.names = [], r.skips = [];
    let h;
    const a = (typeof l == "string" ? l : "").split(/[\s,]+/), d = a.length;
    for (h = 0; h < d; h++)
      a[h] && (l = a[h].replace(/\*/g, ".*?"), l[0] === "-" ? r.skips.push(new RegExp("^" + l.slice(1) + "$")) : r.names.push(new RegExp("^" + l + "$")));
  }
  function s() {
    const l = [
      ...r.names.map(c),
      ...r.skips.map(c).map((h) => "-" + h)
    ].join(",");
    return r.enable(""), l;
  }
  function u(l) {
    if (l[l.length - 1] === "*")
      return !0;
    let h, a;
    for (h = 0, a = r.skips.length; h < a; h++)
      if (r.skips[h].test(l))
        return !1;
    for (h = 0, a = r.names.length; h < a; h++)
      if (r.names[h].test(l))
        return !0;
    return !1;
  }
  function c(l) {
    return l.toString().substring(2, l.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function o(l) {
    return l instanceof Error ? l.stack || l.message : l;
  }
  function y() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var ca = ua;
(function(e, t) {
  t.formatArgs = n, t.save = i, t.load = s, t.useColors = r, t.storage = u(), t.destroy = /* @__PURE__ */ (() => {
    let o = !1;
    return () => {
      o || (o = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function r() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let o;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (o = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(o[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function n(o) {
    if (o[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + o[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const y = "color: " + this.color;
    o.splice(1, 0, y, "color: inherit");
    let l = 0, h = 0;
    o[0].replace(/%[a-zA-Z%]/g, (a) => {
      a !== "%%" && (l++, a === "%c" && (h = l));
    }), o.splice(h, 0, y);
  }
  t.log = console.debug || console.log || (() => {
  });
  function i(o) {
    try {
      o ? t.storage.setItem("debug", o) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function s() {
    let o;
    try {
      o = t.storage.getItem("debug");
    } catch {
    }
    return !o && typeof process < "u" && "env" in process && (o = void 0), o;
  }
  function u() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = ca(t);
  const { formatters: c } = e.exports;
  c.j = function(o) {
    try {
      return JSON.stringify(o);
    } catch (y) {
      return "[UnexpectedJSONParseError]: " + y.message;
    }
  };
})(Ft, Ft.exports);
var fa = Ft.exports;
const xe = /* @__PURE__ */ Zr(fa), za = xe("refact"), la = xe("app");
xe("component");
xe("integrations");
xe("tables");
const Qa = A("chatThread/new");
A("chatThread/newIntegrationChat");
const da = A(
  "chatThread/response"
);
A("chatTitleGeneration/response");
A(
  "chatThread/askQuestion"
);
A(
  "chatThread/setLastUserMessageId"
);
A(
  "chatThread/setIsNewChatSuggested"
);
A(
  "chatThread/setIsNewChatSuggestionRejected"
);
A("chatThread/backUpMessages");
const vn = A(
  "chatThread/error"
), rt = A(
  "chatThread/doneStreaming"
);
A("chatThread/setChatModel");
A(
  "chatThread/setSystemPrompt"
);
A(
  "chatThread/removeChatFromCache"
);
A(
  "chatThread/restoreChat"
);
A(
  "chatThread/clearError"
);
A("chatThread/enableSend");
const bn = A(
  "chatThread/preventSend"
);
A("chatThread/setToolUse");
A(
  "chat/setAutomaticPatch"
);
A(
  "chat/setEnabledCheckpoints"
);
const pa = A(
  "chatThread/saveTitle"
);
A(
  "chatThread/setSendImmediately"
);
A("chatThread/setChatMode");
A(
  "chatThread/setIntegrationData"
);
A(
  "chatThread/setIsWaiting"
);
const ya = A(
  "chatThread/setMaxNewTokens"
), Ir = A(
  "chatThread/fixBrokenToolMessages"
), Sn = et.withTypes();
Sn("chatThread/generateTitle", ({ messages: e, chatId: t }, r) => {
  const n = r.getState(), i = e.filter(
    (c) => !tt(c) && !xt(c) && c.content !== ""
  );
  la("[DEBUG TITLE]: messagesToSend: ", i);
  const s = qe([
    ...i,
    {
      role: "user",
      content: `Generate a short 2-3 word title for the current chat that reflects the context of the user's query. The title should be specific, avoiding generic terms, and should relate to relevant files, symbols, or objects. If user message contains filename, please make sure that filename remains inside of a generated title. Please ensure the answer is strictly 2-3 words, not paragraphs of text.
Output should be STRICTLY 2-3 words, not explanation.`,
      checkpoints: []
    }
  ]), u = [];
  return ms({
    messages: s,
    model: n.chat.thread.model,
    stream: !0,
    abortSignal: r.signal,
    chatId: t,
    apiKey: n.config.apiKey,
    port: n.config.lspPort
  }).then((c) => {
    var h;
    if (!c.ok)
      return Promise.reject(new Error(c.statusText));
    const o = (h = c.body) == null ? void 0 : h.getReader();
    if (!o) return;
    const y = () => r.dispatch(bn({ id: t })), l = (a) => {
      u.push(a);
    };
    return Ht(o, r.signal, y, l);
  }).catch((c) => (r.dispatch(rt({ id: t })), r.dispatch(vn({ id: t, message: c.message })), r.rejectWithValue(c.message))).finally(() => {
    const c = u.reduce((o, y) => vi(y) && _i(y.choices[0].delta) ? o + y.choices[0].delta.content : o, "");
    r.dispatch(
      pa({ id: t, title: c, isTitleGenerated: !0 })
    ), r.dispatch(rt({ id: t }));
  });
});
function ha(e) {
  const t = vs(e, (s) => tt(s) || sr(s) || mi(s));
  if (t.length === 0) return !1;
  const r = t.reduce((s, u) => sr(u) ? s.concat(u.tool_calls) : s, []);
  if (r.length === 0) return !1;
  const n = t.filter(tt);
  return gn(r, (s, u) => {
    const c = n.find(
      (y) => y.content.tool_call_id === s.id
    ), o = n.find(
      (y) => y.content.tool_call_id === u.id
    );
    return s.function.name === u.function.name && s.function.arguments === u.function.arguments && !!c && !!o && c.content.content === o.content.content;
  });
}
Sn(
  "chatThread/sendChat",
  ({ messages: e, chatId: t, tools: r, mode: n, toolsConfirmed: i, checkpointsEnabled: s }, u) => {
    const c = u.getState(), o = t in c.chat.cache ? c.chat.cache[t] : c.chat.thread.id === t ? c.chat.thread : null, y = ha(e), l = qe(e), h = n ?? (o == null ? void 0 : o.mode), a = o == null ? void 0 : o.last_user_message_id;
    return gs({
      messages: l,
      last_user_message_id: a,
      model: c.chat.thread.model,
      tools: r,
      stream: !0,
      abortSignal: u.signal,
      max_new_tokens: c.chat.max_new_tokens,
      chatId: t,
      apiKey: c.config.apiKey,
      port: c.config.lspPort,
      onlyDeterministicMessages: y,
      toolsConfirmed: i,
      checkpointsEnabled: s,
      integration: o == null ? void 0 : o.integration,
      mode: h
    }).then((d) => {
      var S;
      if (!d.ok)
        return Promise.reject(new Error(d.statusText));
      const g = (S = d.body) == null ? void 0 : S.getReader();
      if (!g) return;
      const v = () => {
        u.dispatch(bn({ id: t })), u.dispatch(Ir({ id: t }));
      }, _ = (m) => {
        const f = da({
          ...m,
          id: t
        });
        return u.dispatch(f);
      };
      return Ht(g, u.signal, v, _);
    }).catch((d) => (u.dispatch(rt({ id: t })), u.dispatch(vn({ id: t, message: d.message })), u.dispatch(Ir({ id: t })), u.rejectWithValue(d.message))).finally(() => {
      u.dispatch(ya(ys)), u.dispatch(rt({ id: t }));
    });
  }
);
const ga = A("fim/request"), ma = A("fim/receive"), _a = A("fim/error"), va = A("fim/ready");
A("fim/clear_error");
A("fim/reset");
const ba = {
  host: "web",
  lspPort: 8001,
  apiKey: null,
  features: {
    statistics: !0,
    vecdb: !0,
    ast: !0,
    images: !0,
    knowledge: !1
  },
  themeProps: {
    appearance: "dark"
  },
  shiftEnterToSubmit: !1
}, Sa = A("config/update"), Ca = A(
  "config/setThemeMode"
), Ra = A("config/setApiKey"), wa = A("config/setAddressURL"), Oa = A("config/feature/change");
Fe(ba, (e) => {
  e.addCase(Sa, (t, r) => {
    t.dev = r.payload.dev ?? t.dev, t.features = r.payload.features ? { ...t.features, ...r.payload.features } : t.features, t.host = r.payload.host ?? t.host, t.lspUrl = r.payload.lspUrl ?? t.lspUrl, t.tabbed = r.payload.tabbed ?? t.tabbed, t.themeProps = r.payload.themeProps ?? t.themeProps, t.apiKey = r.payload.apiKey ?? t.apiKey, t.addressURL = r.payload.addressURL ?? t.addressURL, t.lspPort = r.payload.lspPort ?? t.lspPort, t.keyBindings = r.payload.keyBindings ?? t.keyBindings, t.shiftEnterToSubmit = r.payload.shiftEnterToSubmit ?? t.shiftEnterToSubmit;
  }), e.addCase(Ca, (t, r) => {
    t.themeProps.appearance = r.payload;
  }), e.addCase(Ra, (t, r) => {
    t.apiKey = r.payload;
  }), e.addCase(Oa, (t, r) => {
    t.features = {
      ...t.features ?? {},
      [r.payload.feature]: r.payload.value
    };
  }), e.addCase(wa, (t, r) => {
    t.addressURL = r.payload;
  });
});
const Vt = (e) => e.config.features;
ye(
  Vt,
  (e) => e == null ? void 0 : e.vecdb
);
ye(
  Vt,
  (e) => e == null ? void 0 : e.ast
);
ye(
  Vt,
  (e) => e == null ? void 0 : e.knowledge
);
const Ta = {
  name: "",
  line1: null,
  line2: null,
  // attach: false,
  can_paste: !1,
  path: "",
  cursor: null
}, Ea = A("activeFile/setFileInfo");
Fe(Ta, (e) => {
  e.addCase(Ea, (t, r) => ({ ...t, ...r.payload }));
});
const Aa = {
  language: "",
  code: "",
  path: "",
  basename: ""
}, Pa = A("selected_snippet/set");
Fe(Aa, (e) => {
  e.addCase(Pa, (t, r) => r.payload);
});
const Ka = A("textarea/add"), Wa = A("textarea/replace"), Ma = {
  name: ""
}, ka = A(
  "currentProjectInfo/setCurrentProjectInfo"
);
Fe(
  Ma,
  (e) => {
    e.addCase(ka, (t, r) => r.payload);
  }
);
var Cn = /* @__PURE__ */ ((e) => (e.SETUP_HOST = "setup_host", e.OPEN_EXTERNAL_URL = "open_external_url", e.LOG_OUT = "log_out", e))(Cn || {});
function Gt(e) {
  if (!e || typeof e != "object" || !("type" in e) || typeof e.type != "string") return !1;
  const t = {
    ...Cn
  };
  return Object.values(t).includes(e.type);
}
function Ba(e) {
  return Gt(e) ? e.type === "setup_host" : !1;
}
function Ha(e) {
  return Gt(e) ? e.type === "open_external_url" : !1;
}
function Va(e) {
  return Gt(e) ? e.type === "log_out" : !1;
}
const Ga = A("ide/diffPasteBack"), Ja = A("ide/openSettings"), Ya = A("ide/newFile"), Xa = A("ide/openHotKeys"), Za = A("ide/openFile"), ja = A(
  "ide/openChatInNewTab"
), eu = A(
  "ide/animateFile/start"
), tu = A("ide/animateFile/stop"), ru = A("ide/chatPageChange"), nu = A("ide/escapeKeyPressed"), iu = A("ide/isChatStreaming"), ou = A("ide/isChatReady"), su = A(
  "ide/toolEdit"
), au = {
  request: ga,
  ready: va,
  receive: ma,
  error: _a
};
export {
  Cn as EVENT_NAMES_FROM_SETUP,
  Ka as addInputValue,
  au as fim,
  eu as ideAnimateFileStart,
  tu as ideAnimateFileStop,
  ru as ideChatPageChange,
  Ga as ideDiffPasteBackAction,
  nu as ideEscapeKeyPressed,
  ou as ideIsChatReady,
  iu as ideIsChatStreaming,
  Ya as ideNewFileAction,
  ja as ideOpenChatInNewTab,
  Za as ideOpenFile,
  Xa as ideOpenHotKeys,
  Ja as ideOpenSettingsAction,
  su as ideToolEdit,
  Gt as isActionFromSetup,
  _i as isAssistantDelta,
  xt as isAssistantMessage,
  ps as isCapsResponse,
  $a as isChatContextFileDelta,
  Ia as isChatContextFileMessage,
  vi as isChatResponseChoice,
  xa as isChatUserMessageResponse,
  bs as isCommandCompletionResponse,
  Cs as isCommandPreviewResponse,
  Ts as isCustomPromptsResponse,
  Ye as isDetailMessage,
  gi as isDiffMessage,
  Ua as isDiffResponse,
  Va as isLogOut,
  Ha as isOpenExternalUrl,
  Da as isPlainTextMessage,
  La as isPlainTextResponse,
  Ba as isSetupHost,
  Es as isStatisticDataResponse,
  Os as isSystemPrompts,
  qa as isToolCallDelta,
  sr as isToolCallMessage,
  tt as isToolMessage,
  Na as isToolResponse,
  hi as isUserMessage,
  Qa as newChatAction,
  ka as setCurrentProjectInfo,
  Ea as setFileInfo,
  Wa as setInputValue,
  Pa as setSelectedSnippet,
  Sa as updateConfig
};
